{
  "id": "prt_994a8b89c001KsMqV8qq1mS5DO",
  "messageID": "msg_994a8ab34001qLgDJLb6WXUjHW",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_01K4DsNerVra8q8fXNkmSgTx",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/TruckVisualization.tsx"
    },
    "output": "<file>\n00001| 'use client';\n00002| \n00003| import React from 'react';\n00004| import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\n00005| import { Truck } from 'lucide-react';\n00006| \n00007| interface Cargo {\n00008|   id: string;\n00009|   length: number; // в мм\n00010|   width: number;  // в мм\n00011|   height: number; // в мм\n00012|   weight: number;\n00013|   productName?: string;\n00014| }\n00015| \n00016| interface Orientation {\n00017|   length: number;\n00018|   width: number;\n00019|   height: number;\n00020|   rotationAngle: number; // в градусах\n00021|   flipped: boolean; // перевернут ли груз по высоте\n00022| }\n00023| \n00024| interface CargoPlacement {\n00025|   cargo: Cargo;\n00026|   x: number;\n00027|   y: number;\n00028|   z: number;\n00029|   orientation: Orientation;\n00030|   color: string;\n00031|   projectedVertices: Array<{x: number, y: number}>; // Для 3D отображения\n00032| }\n00033| \n00034| interface TruckVisualizationProps {\n00035|   cargos: Cargo[];\n00036|   isVisible?: boolean;\n00037| }\n00038| \n00039| // Размеры кузова в мм\n00040| const TRUCK_DIMENSIONS = {\n00041|   length: 4200,\n00042|   width: 2025,\n00043|   height: 2025\n00044| };\n00045| \n00046| // Углы поворота для размещения грузов (в градусах)\n00047| const ROTATION_ANGLES = [0, 45, 90, 135, 180, 225, 270, 315];\n00048| \n00049| // Цвета для разных грузов\n00050| const CARGO_COLORS = [\n00051|   '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',\n00052|   '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43',\n00053|   '#10AC84', '#EE5A24', '#0984E3', '#6C5CE7', '#FD79A8'\n00054| ];\n00055| \n00056| export default function TruckVisualization({ cargos, isVisible = false }: TruckVisualizationProps) {\n00057|   \n00058|   // Функция проверки ключевых слов\n00059|   const isChairOrSeat = (productName?: string) => {\n00060|     if (!productName) return false;\n00061|     const lowerName = productName.toLowerCase();\n00062|     return lowerName.includes('стул') || lowerName.includes('кресло');\n00063|   };\n00064| \n00065|   // Генерация всех возможных ориентаций груза\n00066|   const generateOrientations = (cargo: Cargo): Orientation[] => {\n00067|     const orientations: Orientation[] = [];\n00068|     const baseDimensions = [\n00069|       [cargo.length, cargo.width, cargo.height],\n00070|       [cargo.width, cargo.length, cargo.height],\n00071|       [cargo.length, cargo.height, cargo.width],\n00072|       [cargo.height, cargo.length, cargo.width],\n00073|       [cargo.width, cargo.height, cargo.length],\n00074|       [cargo.height, cargo.width, cargo.length]\n00075|     ];\n00076| \n00077|     // Для стульев/кресел ограничиваем повороты (нельзя переворачивать)\n00078|     const allowedDimensions = isChairOrSeat(cargo.productName) \n00079|       ? baseDimensions.slice(0, 2) // Только первые 2 варианта (без поворота по высоте)\n00080|       : baseDimensions;\n00081| \n00082|     allowedDimensions.forEach(([l, w, h]) => {\n00083|       ROTATION_ANGLES.forEach(angle => {\n00084|         // Вычисляем размеры после поворота\n00085|         const rad = (angle * Math.PI) / 180;\n00086|         const cos = Math.abs(Math.cos(rad));\n00087|         const sin = Math.abs(Math.sin(rad));\n00088|         \n00089|         const rotatedLength = l * cos + w * sin;\n00090|         const rotatedWidth = l * sin + w * cos;\n00091| \n00092|         orientations.push({\n00093|           length: rotatedLength,\n00094|           width: rotatedWidth,\n00095|           height: h,\n00096|           rotationAngle: angle,\n00097|           flipped: h !== cargo.height\n00098|         });\n00099|       });\n00100|     });\n00101| \n00102|     return orientations;\n00103|   };\n00104| \n00105|   // Проверка пересечения двух прямоугольников с учетом поворота\n00106|   const checkCollision = (\n00107|     x1: number, y1: number, x2: number, y2: number,\n00108|     length1: number, width1: number, length2: number, width2: number,\n00109|     angle1: number, angle2: number\n00110|   ): boolean => {\n00111|     // Упрощенная проверка через ограничивающие прямоугольники\n00112|     const rad1 = (angle1 * Math.PI) / 180;\n00113|     const rad2 = (angle2 * Math.PI) / 180;\n00114|     \n00115|     const cos1 = Math.abs(Math.cos(rad1));\n00116|     const sin1 = Math.abs(Math.sin(rad1));\n00117|     const cos2 = Math.abs(Math.cos(rad2));\n00118|     const sin2 = Math.abs(Math.sin(rad2));\n00119|     \n00120|     const bbox1 = {\n00121|       minX: x1,\n00122|       maxX: x1 + length1 * cos1 + width1 * sin1,\n00123|       minY: y1,\n00124|       maxY: y1 + length1 * sin1 + width1 * cos1\n00125|     };\n00126|     \n00127|     const bbox2 = {\n00128|       minX: x2,\n00129|       maxX: x2 + length2 * cos2 + width2 * sin2,\n00130|       minY: y2,\n00131|       maxY: y2 + length2 * sin2 + width2 * cos2\n00132|     };\n00133| \n00134|     return !(bbox1.maxX <= bbox2.minX || bbox2.maxX <= bbox1.minX ||\n00135|              bbox1.maxY <= bbox2.minY || bbox2.maxY <= bbox1.minY);\n00136|   };\n00137| \n00138|   // Проверка валидности позиции\n00139|   const isPositionValid = (\n00140|     x: number, y: number, z: number,\n00141|     orientation: Orientation,\n00142|     placements: CargoPlacement[],\n00143|     cargo: Cargo\n00144|   ): boolean => {\n00145|     \n00146|     // Проверяем границы кузова\n00147|     const rad = (orientation.rotationAngle * Math.PI) / 180;\n00148|     const cos = Math.abs(Math.cos(rad));\n00149|     const sin = Math.abs(Math.sin(rad));\n00150|     \n00151|     const effectiveLength = orientation.length * cos + orientation.width * sin;\n00152|     const effectiveWidth = orientation.length * sin + orientation.width * cos;\n00153|     \n00154|     if (x + effectiveLength > TRUCK_DIMENSIONS.length || \n00155|         y + effectiveWidth > TRUCK_DIMENSIONS.width ||\n00156|         z + orientation.height > TRUCK_DIMENSIONS.height) {\n00157|       return false;\n00158|     }\n00159| \n00160|     // Проверяем пересечения с уже размещенными грузами\n00161|     for (const placement of placements) {\n00162|       // Проверка по высоте\n00163|       if (!(z >= placement.z + placement.orientation.height || \n00164|             z + orientation.height <= placement.z)) {\n00165|         \n00166|         // Если высоты пересекаются, проверяем пересечение по площади\n00167|         if (checkCollision(\n00168|           x, y, placement.x, placement.y,\n00169|           orientation.length, orientation.width,\n00170|           placement.orientation.length, placement.orientation.width,\n00171|           orientation.rotationAngle, placement.orientation.rotationAngle\n00172|         )) {\n00173|           return false;\n00174|         }\n00175|       }\n00176|     }\n00177| \n00178|     // Проверяем правила размещения\n00179|     if (z > 0) { // Груз не на полу\n00180|       const supportingCargos = placements.filter(p => \n00181|         z === p.z + p.orientation.height && // Стоит прямо на другом грузе\n00182|         !checkCollision(\n00183|           x, y, p.x, p.y,\n00184|           orientation.length, orientation.width,\n00185|           p.orientation.length, p.orientation.width,\n00186|           orientation.rotationAngle, p.orientation.rotationAngle\n00187|         ) === false // Есть пересечение по площади (поддержка)\n00188|       );\n00189| \n00190|       if (supportingCargos.length === 0) {\n00191|         return false; // Должен на чем-то стоять\n00192|       }\n00193| \n00194|       // Правило по весу\n00195|       for (const supporting of supportingCargos) {\n00196|         if (cargo.weight > supporting.cargo.weight) {\n00197|           return false;\n00198|         }\n00199|       }\n00200| \n00201|       // Правила для стульев/кресел\n00202|       if (isChairOrSeat(cargo.productName)) {\n00203|         const allSupportingAreChairs = supportingCargos.every(p => \n00204|           isChairOrSeat(p.cargo.productName)\n00205|         );\n00206|         \n00207|         if (!allSupportingAreChairs) {\n00208|           return false;\n00209|         }\n00210| \n00211|         // Максимум 2 стула друг на друге\n00212|         let chairLevels = 1;\n00213|         let currentZ = z;\n00214|         \n00215|         while (currentZ > 0) {\n00216|           const chairsBelow = placements.filter(p =>\n00217|             p.z + p.orientation.height === currentZ &&\n00218|             isChairOrSeat(p.cargo.productName)\n00219|           );\n00220|           \n00221|           if (chairsBelow.length > 0) {\n00222|             chairLevels++;\n00223|             currentZ = Math.min(...chairsBelow.map(p => p.z));\n00224|           } else {\n00225|             break;\n00226|           }\n00227|         }\n00228|         \n00229|         if (chairLevels > 2) {\n00230|           return false;\n00231|         }\n00232|       } else {\n00233|         // Обычные грузы нельзя ставить на стулья\n00234|         const hasChairSupport = supportingCargos.some(p => \n00235|           isChairOrSeat(p.cargo.productName)\n00236|         );\n00237|         \n00238|         if (hasChairSupport) {\n00239|           return false;\n00240|         }\n00241|       }\n00242|     }\n00243| \n00244|     return true;\n00245|   };\n00246| \n00247|   // Расчет площади пола, занимаемой размещениями\n00248|   const calculateFloorArea = (placements: CargoPlacement[], newPlacement?: CargoPlacement) => {\n00249|     const allPlacements = newPlacement ? [...placements, newPlacement] : placements;\n00250|     \n00251|     if (allPlacements.length === 0) return 0;\n00252| \n00253|     let minX = Infinity, maxX = 0, minY = Infinity, maxY = 0;\n00254| \n00255|     allPlacements.forEach(p => {\n00256|       const rad = (p.orientation.rotationAngle * Math.PI) / 180;\n00257|       const cos = Math.abs(Math.cos(rad));\n00258|       const sin = Math.abs(Math.sin(rad));\n00259|       \n00260|       const effectiveLength = p.orientation.length * cos + p.orientation.width * sin;\n00261|       const effectiveWidth = p.orientation.length * sin + p.orientation.width * cos;\n00262|       \n00263|       minX = Math.min(minX, p.x);\n00264|       maxX = Math.max(maxX, p.x + effectiveLength);\n00265|       minY = Math.min(minY, p.y);\n00266|       maxY = Math.max(maxY, p.y + effectiveWidth);\n00267|     });\n00268| \n00269|     return (maxX - minX) * (maxY - minY);\n00270|   };\n00271| \n00272|   // Основной алгоритм размещения\n00273|   const calculateCargoPlacement = (): CargoPlacement[] => {\n00274|     if (!cargos.length) return [];\n00275| \n00276|     // Фильтруем только заполненные грузы\n00277|     const validCargos = cargos.filter(cargo => \n00278|       cargo.length > 0 && cargo.width > 0 && cargo.height > 0 && cargo.weight > 0\n00279|     );\n00280| \n00281|     if (!validCargos.length) return [];\n00282| \n00283|     // Сортировка: стулья первыми, потом по весу, потом по объему\n00284|     const sortedCargos = [...validCargos].sort((a, b) => {\n00285|       const aIsChair = isChairOrSeat(a.productName);\n00286|       const bIsChair = isChairOrSeat(b.productName);\n00287|       \n00288|       if (aIsChair && !bIsChair) return -1;\n00289|       if (!aIsChair && bIsChair) return 1;\n00290|       \n00291|       const weightDiff = b.weight - a.weight;\n00292|       if (weightDiff !== 0) return weightDiff;\n00293|       \n00294|       const volumeA = a.length * a.width * a.height;\n00295|       const volumeB = b.length * b.width * b.height;\n00296|       return volumeB - volumeA;\n00297|     });\n00298| \n00299|     const placements: CargoPlacement[] = [];\n00300| \n00301|     sortedCargos.forEach((cargo, index) => {\n00302|       const color = CARGO_COLORS[index % CARGO_COLORS.length];\n00303|       const orientations = generateOrientations(cargo);\n00304|       \n00305|       let bestPlacement: CargoPlacement | null = null;\n00306|       let bestScore = Infinity;\n00307| \n00308|       // Генерируем возможные Z позиции\n00309|       const possibleZ = [0];\n00310|       placements.forEach(p => {\n00311|         const topZ = p.z + p.orientation.height;\n00312|         if (topZ <= TRUCK_DIMENSIONS.height - 100) { // Минимум 100мм сверху\n00313|           possibleZ.push(topZ);\n00314|         }\n00315|       });\n00316|       \n00317|       const uniqueZ = possibleZ.filter((value, index, self) => self.indexOf(value) === index);\n00318|       const sortedZ = uniqueZ.sort((a, b) => a - b);\n00319| \n00320|       // Перебираем все ориентации и позиции\n00321|       for (const orientation of orientations) {\n00322|         for (const z of sortedZ) {\n00323|           if (z + orientation.height > TRUCK_DIMENSIONS.height) continue;\n00324| \n00325|           // Более частая сетка для точного размещения\n00326|           const step = 25; // 25мм шаг\n00327|           \n00328|           for (let y = 0; y <= TRUCK_DIMENSIONS.width - 50; y += step) {\n00329|             for (let x = 0; x <= TRUCK_DIMENSIONS.length - 50; x += step) {\n00330|               \n00331|               if (isPositionValid(x, y, z, orientation, placements, cargo)) {\n00332|                 const testPlacement: CargoPlacement = {\n00333|                   cargo,\n00334|                   x, y, z,\n00335|                   orientation,\n00336|                   color,\n00337|                   projectedVertices: []\n00338|                 };\n00339| \n00340|                 // Оценка: приоритет площади пола, потом высота, потом объем\n00341|                 const floorArea = calculateFloorArea(placements, testPlacement);\n00342|                 const heightPenalty = z * 0.001;\n00343|                 const volumePenalty = (floorArea * orientation.height) * 0.000001;\n00344|                 const score = floorArea + heightPenalty + volumePenalty;\n00345| \n00346|                 if (score < bestScore) {\n00347|                   bestScore = score;\n00348|                   bestPlacement = testPlacement;\n00349|                 }\n00350|               }\n00351|             }\n00352|           }\n00353|         }\n00354|       }\n00355| \n00356|       if (bestPlacement) {\n00357|         // Вычисляем проекционные вершины для 3D отображения\n00358|         bestPlacement.projectedVertices = calculateProjectedVertices(bestPlacement);\n00359|         placements.push(bestPlacement);\n00360|       }\n00361|     });\n00362| \n00363|     return placements;\n00364|   };\n00365| \n00366|   // Вычисление проекционных вершин для 3D отображения\n00367|   const calculateProjectedVertices = (placement: CargoPlacement) => {\n00368|     const { x, y, z, orientation } = placement;\n00369|     const angle = orientation.rotationAngle * Math.PI / 180;\n00370|     \n00371|     // Основные вершины параллелепипеда\n00372|     const vertices3D = [\n00373|       [x, y, z],\n00374|       [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z],\n00375|       [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n00376|        y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z],\n00377|       [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z],\n00378|       // Верхние вершины\n00379|       [x, y, z + orientation.height],\n00380|       [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z + orientation.height],\n00381|       [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n00382|        y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z + orientation.height],\n00383|       [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z + orientation.height]\n00384|     ];\n00385| \n00386|     // Изометрическая проекция (вид сзади 3/4)\n00387|     return vertices3D.map(([x3d, y3d, z3d]) => {\n00388|       const scale = 0.08; // Масштаб для отображения\n00389|       const offsetX = 50;\n00390|       const offsetY = 300;\n00391|       \n00392|       // Изометрия: поворот на 45° по Y, потом наклон на 30°\n00393|       const projX = (x3d - y3d) * Math.cos(Math.PI / 6) * scale + offsetX;\n00394|       const projY = offsetY - ((x3d + y3d) * Math.sin(Math.PI / 6) + z3d) * scale;\n00395|       \n00396|       return { x: projX, y: projY };\n00397|     });\n00398|   };\n00399| \n00400|   const placements = calculateCargoPlacement();\n00401| \n00402|   // Расчет статистики\n00403|   const calculateStats = () => {\n00404|     if (!placements.length) return null;\n00405| \n00406|     const floorArea = calculateFloorArea(placements);\n00407|     \n00408|     let maxX = 0, maxY = 0, maxZ = 0;\n00409|     placements.forEach(p => {\n00410|       const rad = (p.orientation.rotationAngle * Math.PI) / 180;\n00411|       const cos = Math.abs(Math.cos(rad));\n00412|       const sin = Math.abs(Math.sin(rad));\n00413|       \n00414|       const effectiveLength = p.orientation.length * cos + p.orientation.width * sin;\n00415|       const effectiveWidth = p.orientation.length * sin + p.orientation.width * cos;\n00416|       \n00417|       maxX = Math.max(maxX, p.x + effectiveLength);\n00418|       maxY = Math.max(maxY, p.y + effectiveWidth);\n00419|       maxZ = Math.max(maxZ, p.z + p.orientation.height);\n00420|     });\n00421| \n00422|     const occupiedVolume = (maxX * maxY * maxZ) / 1000000000; // в м³\n00423|     const floorUtilization = (floorArea / ((TRUCK_DIMENSIONS.length * TRUCK_DIMENSIONS.width))) * 100;\n00424| \n00425|     return {\n00426|       occupiedFloorArea: (floorArea / 1000000).toFixed(2), // в м²\n00427|       occupiedVolume: occupiedVolume.toFixed(3),\n00428|       floorUtilization: floorUtilization.toFixed(1),\n00429|       dimensions: {\n00430|         length: (maxX / 1000).toFixed(2),\n00431|         width: (maxY / 1000).toFixed(2),\n00432|         height: (maxZ / 1000).toFixed(2)\n00433|       }\n00434|     };\n00435|   };\n00436| \n00437|   const stats = calculateStats();\n00438| \n00439|   if (!isVisible) return null;\n00440| \n00441|   return (\n00442|     <Card className=\"bg-gray-800 border-gray-700\">\n00443|       <CardHeader className=\"pb-3\">\n00444|         <CardTitle className=\"text-white flex items-center gap-2 text-lg\">\n00445|           <Truck className=\"h-4 w-4\" />\n00446|           3D Визуализация размещения в кузове (вид сзади 3/4)\n00447|         </CardTitle>\n00448|       </CardHeader>\n00449|       <CardContent>\n00450|         {/* 3D SVG визуализация кузова */}\n00451|         <div className=\"bg-gray-900 p-4 rounded-lg mb-4\">\n00452|           <svg \n00453|             viewBox=\"0 0 600 400\" \n00454|             className=\"w-full h-96 border border-gray-600 bg-gray-950\"\n00455|             style={{ maxHeight: '480px' }}\n00456|           >\n00457|             {/* Контур кузова в изометрии */}\n00458|             <g stroke=\"#4B5563\" strokeWidth=\"2\" fill=\"none\">\n00459|               {/* Задняя стенка */}\n00460|               <rect x=\"50\" y=\"100\" width=\"163\" height=\"163\" strokeDasharray=\"3,3\" />\n00461|               \n00462|               {/* Правая боковая стенка */}\n00463|               <polygon points=\"213,100 350,50 350,213 213,263\" strokeDasharray=\"3,3\" />\n00464|               \n00465|               {/* Пол */}\n00466|               <polygon points=\"50,263 213,263 350,213 187,213\" fill=\"#374151\" fillOpacity=\"0.3\" />\n00467|               \n00468|               {/* Верх */}\n00469|               <polygon points=\"50,100 213,100 350,50 187,50\" strokeDasharray=\"3,3\" />\n00470|               \n00471|               {/* Левая стенка (видимая часть) */}\n00472|               <line x1=\"50\" y1=\"100\" x2=\"187\" y2=\"50\" strokeDasharray=\"3,3\" />\n00473|               <line x1=\"50\" y1=\"263\" x2=\"187\" y2=\"213\" strokeDasharray=\"3,3\" />\n00474|             </g>\n00475|             \n00476|             {/* Размеры кузова */}\n00477|             <text x=\"300\" y=\"40\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"10\">\n00478|               4200×2025×2025 мм\n00479|             </text>\n00480|             \n00481|             {/* Отображение размещенных грузов */}\n00482|             {placements.map((placement, index) => {\n00483|               const vertices = placement.projectedVertices;\n00484|               if (vertices.length < 8) return null;\n00485| \n00486|               return (\n00487|                 <g key={`cargo-3d-${index}`}>\n00488|                   {/* Нижняя грань */}\n00489|                   <polygon\n00490|                     points={`${vertices[0].x},${vertices[0].y} ${vertices[1].x},${vertices[1].y} ${vertices[2].x},${vertices[2].y} ${vertices[3].x},${vertices[3].y}`}\n00491|                     fill={placement.color}\n00492|                     fillOpacity=\"0.6\"\n00493|                     stroke={placement.color}\n00494|                     strokeWidth=\"1\"\n00495|                   />\n00496|                   \n00497|                   {/* Верхняя грань */}\n00498|                   <polygon\n00499|                     points={`${vertices[4].x},${vertices[4].y} ${vertices[5].x},${vertices[5].y} ${vertices[6].x},${vertices[6].y} ${vertices[7].x},${vertices[7].y}`}\n00500|                     fill={placement.color}\n00501|                     fillOpacity=\"0.8\"\n00502|                     stroke={placement.color}\n00503|                     strokeWidth=\"1\"\n00504|                   />\n00505|                   \n00506|                   {/* Боковые грани */}\n00507|                   <polygon\n00508|                     points={`${vertices[1].x},${vertices[1].y} ${vertices[2].x},${vertices[2].y} ${vertices[6].x},${vertices[6].y} ${vertices[5].x},${vertices[5].y}`}\n00509|                     fill={placement.color}\n00510|                     fillOpacity=\"0.7\"\n00511|                     stroke={placement.color}\n00512|                     strokeWidth=\"1\"\n00513|                   />\n00514|                   \n00515|                   <polygon\n00516|                     points={`${vertices[2].x},${vertices[2].y} ${vertices[3].x},${vertices[3].y} ${vertices[7].x},${vertices[7].y} ${vertices[6].x},${vertices[6].y}`}\n00517|                     fill={placement.color}\n00518|                     fillOpacity=\"0.5\"\n00519|                     stroke={placement.color}\n00520|                     strokeWidth=\"1\"\n00521|                   />\n00522| \n00523|                   {/* Номер груза */}\n00524|                   <text\n00525|                     x={(vertices[4].x + vertices[6].x) / 2}\n00526|                     y={(vertices[4].y + vertices[6].y) / 2}\n00527|                     textAnchor=\"middle\"\n00528|                     dominantBaseline=\"middle\"\n00529|                     fill=\"white\"\n00530|                     fontSize=\"8\"\n00531|                     fontWeight=\"bold\"\n00532|                   >\n00533|                     {index + 1}\n00534|                   </text>\n00535|                 </g>\n00536|               );\n00537|             })}\n00538|           </svg>\n00539|         </div>\n00540| \n00541|         {/* Статистика размещения */}\n00542|         {stats && (\n00543|           <div className=\"grid grid-cols-2 gap-4 text-sm\">\n00544|             <div className=\"space-y-2\">\n00545|               <h4 className=\"font-medium text-white\">Занятые размеры:</h4>\n00546|               <div className=\"text-gray-300 space-y-1\">\n00547|                 <div>Длина: {stats.dimensions.length} м</div>\n00548|                 <div>Ширина: {stats.dimensions.width} м</div>\n00549|                 <div>Высота: {stats.dimensions.height} м</div>\n00550|               </div>\n00551|             </div>\n00552|             <div className=\"space-y-2\">\n00553|               <h4 className=\"font-medium text-white\">Использование:</h4>\n00554|               <div className=\"text-gray-300 space-y-1\">\n00555|                 <div>Площадь пола: {stats.occupiedFloorArea} м²</div>\n00556|                 <div>Объем: {stats.occupiedVolume} м³</div>\n00557|                 <div>Загрузка пола: {stats.floorUtilization}%</div>\n00558|               </div>\n00559|             </div>\n00560|           </div>\n00561|         )}\n00562| \n00563|         {/* Легенда грузов */}\n00564|         {placements.length > 0 && (\n00565|           <div className=\"mt-4\">\n00566|             <h4 className=\"font-medium text-white mb-2\">Размещенные грузы:</h4>\n00567|             <div className=\"grid grid-cols-1 gap-2 text-xs max-h-32 overflow-y-auto\">\n00568|               {placements.map((placement, index) => (\n00569|                 <div key={`legend-${index}`} className=\"flex items-center gap-2\">\n00570|                   <div \n00571|                     className=\"w-3 h-3 rounded\"\n00572|                     style={{ backgroundColor: placement.color }}\n00573|                   />\n00574|                   <span className=\"text-gray-300\">\n00575|                     Груз {index + 1}: {Math.round(placement.orientation.length)}×{Math.round(placement.orientation.width)}×{Math.round(placement.orientation.height)} мм\n00576|                     {placement.orientation.rotationAngle !== 0 && (\n00577|                       <span className=\"text-blue-300\"> (повернут {placement.orientation.rotationAngle}°)</span>\n00578|                     )}\n00579|                   </span>\n00580|                 </div>\n00581|               ))}\n00582|             </div>\n00583|           </div>\n00584|         )}\n00585|       </CardContent>\n00586|     </Card>\n00587|   );\n00588| }\n</file>",
    "metadata": {
      "preview": "'use client';\n\nimport React from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Truck } from 'lucide-react';\n\ninterface Cargo {\n  id: string;\n  length: number; // в мм\n  width: number;  // в мм\n  height: number; // в мм\n  weight: number;\n  productName?: string;\n}\n\ninterface Orientation {\n  length: number;\n  width: number;\n  height: number;\n  rotationAngle: number; // в градусах"
    },
    "title": "components/TruckVisualization.tsx",
    "time": {
      "start": 1759135709668,
      "end": 1759135709677
    }
  }
}