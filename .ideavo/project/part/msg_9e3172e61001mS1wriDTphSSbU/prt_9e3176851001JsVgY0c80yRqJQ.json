{
  "id": "prt_9e3176851001JsVgY0c80yRqJQ",
  "messageID": "msg_9e3172e61001mS1wriDTphSSbU",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "call_03843860",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "app/api/external/route.ts",
      "content": "import { NextRequest, NextResponse } from 'next/server';\nimport { apiRequestWithTimeout } from '@/lib/api-utils';\n\n// Supported transport companies\nconst SUPPORTED_COMPANIES = [\n  'pek',\n  'dellin',\n  'vozovoz',\n  'railcontinent',\n  'nordwheel'\n] as const;\n\ntype SupportedCompany = typeof SUPPORTED_COMPANIES[number];\n\ninterface FreightCalculationRequest {\n  company: SupportedCompany;\n  fromCity: string;\n  toCity: string;\n  cargo: Array<{\n    length: number;\n    width: number;\n    height: number;\n    weight: number;\n    quantity?: number;\n  }>;\n  options?: {\n    insurance?: boolean;\n    packaging?: boolean;\n    urgent?: boolean;\n  };\n}\n\ninterface FreightCalculationResponse {\n  success: boolean;\n  company: string;\n  calculation: {\n    totalCost: number;\n    currency: string;\n    deliveryTime: {\n      min: number;\n      max: number;\n      unit: string;\n    };\n    breakdown?: {\n      baseCost: number;\n      insurance?: number;\n      packaging?: number;\n      urgent?: number;\n    };\n  };\n  metadata: {\n    requestId: string;\n    timestamp: string;\n    processingTime: number;\n  };\n  error?: string;\n}\n\n// Rate limiting (simple in-memory store - use Redis in production)\nconst rateLimitStore = new Map<string, { count: number; resetTime: number }>();\nconst RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute\nconst RATE_LIMIT_MAX_REQUESTS = 100; // requests per window\n\nfunction checkRateLimit(clientId: string): boolean {\n  const now = Date.now();\n  const clientData = rateLimitStore.get(clientId);\n\n  if (!clientData || now > clientData.resetTime) {\n    rateLimitStore.set(clientId, { count: 1, resetTime: now + RATE_LIMIT_WINDOW });\n    return true;\n  }\n\n  if (clientData.count >= RATE_LIMIT_MAX_REQUESTS) {\n    return false;\n  }\n\n  clientData.count++;\n  return true;\n}\n\nfunction getClientId(request: NextRequest): string {\n  // Use API key or IP address for rate limiting\n  const apiKey = request.headers.get('x-api-key');\n  const forwardedFor = request.headers.get('x-forwarded-for');\n  const realIp = request.headers.get('x-real-ip');\n  const clientIp = forwardedFor || realIp || request.ip || 'unknown';\n\n  return apiKey || clientIp;\n}\n\nexport async function POST(request: NextRequest) {\n  const startTime = Date.now();\n  const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n  try {\n    // Rate limiting\n    const clientId = getClientId(request);\n    if (!checkRateLimit(clientId)) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'Rate limit exceeded. Please try again later.',\n          metadata: {\n            requestId,\n            timestamp: new Date().toISOString(),\n            processingTime: Date.now() - startTime\n          }\n        } as FreightCalculationResponse,\n        {\n          status: 429,\n          headers: {\n            'Retry-After': '60',\n            'X-RateLimit-Limit': RATE_LIMIT_MAX_REQUESTS.toString(),\n            'X-RateLimit-Remaining': '0',\n            'X-RateLimit-Reset': (Date.now() + RATE_LIMIT_WINDOW).toString()\n          }\n        }\n      );\n    }\n\n    // Parse request body\n    const body: FreightCalculationRequest = await request.json();\n\n    // Validate request\n    if (!body.company || !SUPPORTED_COMPANIES.includes(body.company)) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: `Invalid company. Supported companies: ${SUPPORTED_COMPANIES.join(', ')}`,\n          metadata: {\n            requestId,\n            timestamp: new Date().toISOString(),\n            processingTime: Date.now() - startTime\n          }\n        } as FreightCalculationResponse,\n        { status: 400 }\n      );\n    }\n\n    if (!body.fromCity || !body.toCity) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'fromCity and toCity are required',\n          metadata: {\n            requestId,\n            timestamp: new Date().toISOString(),\n            processingTime: Date.now() - startTime\n          }\n        } as FreightCalculationResponse,\n        { status: 400 }\n      );\n    }\n\n    if (!body.cargo || !Array.isArray(body.cargo) || body.cargo.length === 0) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: 'cargo array is required and must not be empty',\n          metadata: {\n            requestId,\n            timestamp: new Date().toISOString(),\n            processingTime: Date.now() - startTime\n          }\n        } as FreightCalculationResponse,\n        { status: 400 }\n      );\n    }\n\n    // Validate cargo items\n    for (const item of body.cargo) {\n      if (!item.length || !item.width || !item.height || !item.weight) {\n        return NextResponse.json(\n          {\n            success: false,\n            error: 'Each cargo item must have length, width, height, and weight',\n            metadata: {\n              requestId,\n              timestamp: new Date().toISOString(),\n              processingTime: Date.now() - startTime\n            }\n          } as FreightCalculationResponse,\n          { status: 400 }\n        );\n      }\n\n      if (item.length <= 0 || item.width <= 0 || item.height <= 0 || item.weight <= 0) {\n        return NextResponse.json(\n          {\n            success: false,\n            error: 'Cargo dimensions and weight must be positive numbers',\n            metadata: {\n              requestId,\n              timestamp: new Date().toISOString(),\n              processingTime: Date.now() - startTime\n            }\n          } as FreightCalculationResponse,\n          { status: 400 }\n        );\n      }\n    }\n\n    // Route to appropriate API endpoint\n    const apiEndpoint = getApiEndpoint(body.company);\n    const apiPayload = transformPayload(body);\n\n    console.log(`[External API] Routing request ${requestId} to ${body.company} API`);\n\n    const response = await apiRequestWithTimeout(apiEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-Request-ID': requestId\n      },\n      body: JSON.stringify(apiPayload)\n    }, { timeout: 30000 });\n\n    const result = await response.json();\n\n    if (!response.ok) {\n      return NextResponse.json(\n        {\n          success: false,\n          error: result.error || 'API request failed',\n          metadata: {\n            requestId,\n            timestamp: new Date().toISOString(),\n            processingTime: Date.now() - startTime\n          }\n        } as FreightCalculationResponse,\n        { status: response.status }\n      );\n    }\n\n    // Transform response to standardized format\n    const standardizedResponse = transformResponse(body.company, result, requestId, startTime);\n\n    return NextResponse.json(standardizedResponse, {\n      headers: {\n        'X-Request-ID': requestId,\n        'X-API-Version': '1.0.0'\n      }\n    });\n\n  } catch (error: any) {\n    console.error(`[External API] Error processing request ${requestId}:`, error);\n\n    return NextResponse.json(\n      {\n        success: false,\n        error: 'Internal server error',\n        metadata: {\n          requestId,\n          timestamp: new Date().toISOString(),\n          processingTime: Date.now() - startTime\n        }\n      } as FreightCalculationResponse,\n      { status: 500 }\n    );\n  }\n}\n\nfunction getApiEndpoint(company: SupportedCompany): string {\n  const endpoints = {\n    pek: '/api/pek',\n    dellin: '/api/dellin-packages',\n    vozovoz: '/api/vozovoz',\n    railcontinent: '/api/rail-continent',\n    nordwheel: '/api/test'\n  };\n\n  return endpoints[company];\n}\n\nfunction transformPayload(body: FreightCalculationRequest): any {\n  // Transform to the format expected by each company's API\n  const basePayload = {\n    fromCity: body.fromCity,\n    toCity: body.toCity,\n    cargos: body.cargo.map(item => ({\n      length: item.length,\n      width: item.width,\n      height: item.height,\n      weight: item.weight,\n      quantity: item.quantity || 1\n    }))\n  };\n\n  // Add company-specific options\n  switch (body.company) {\n    case 'pek':\n      return {\n        ...basePayload,\n        method: 'calculate'\n      };\n\n    case 'dellin':\n      return {\n        ...basePayload,\n        method: 'calculate'\n      };\n\n    case 'vozovoz':\n      return {\n        ...basePayload,\n        method: 'calculate'\n      };\n\n    case 'railcontinent':\n      return {\n        ...basePayload,\n        method: 'calculate'\n      };\n\n    case 'nordwheel':\n      return {\n        ...basePayload,\n        service: 'nordwheel'\n      };\n\n    default:\n      return basePayload;\n  }\n}\n\nfunction transformResponse(\n  company: SupportedCompany,\n  apiResponse: any,\n  requestId: string,\n  startTime: number\n): FreightCalculationResponse {\n  // Transform API response to standardized format\n  // This would need to be customized based on each API's response format\n\n  const processingTime = Date.now() - startTime;\n\n  // Default transformation - would need specific logic for each company\n  return {\n    success: true,\n    company,\n    calculation: {\n      totalCost: apiResponse.totalCost || apiResponse.cost || 0,\n      currency: apiResponse.currency || 'RUB',\n      deliveryTime: {\n        min: apiResponse.deliveryTime?.min || apiResponse.minDays || 1,\n        max: apiResponse.deliveryTime?.max || apiResponse.maxDays || 7,\n        unit: 'days'\n      },\n      breakdown: apiResponse.breakdown || undefined\n    },\n    metadata: {\n      requestId,\n      timestamp: new Date().toISOString(),\n      processingTime\n    }\n  };\n}\n\n// GET endpoint for API documentation\nexport async function GET() {\n  return NextResponse.json({\n    name: 'Freight Calculator External API',\n    version: '1.0.0',\n    description: 'REST API for freight cost calculations across Russian transport companies',\n    baseUrl: '/api/external',\n    endpoints: {\n      'POST /api/external': {\n        description: 'Calculate freight costs',\n        authentication: 'API Key (X-API-Key header) or IP-based rate limiting',\n        rateLimit: `${RATE_LIMIT_MAX_REQUESTS} requests per minute`,\n        requestBody: {\n          company: {\n            type: 'string',\n            required: true,\n            enum: SUPPORTED_COMPANIES,\n            description: 'Transport company to use for calculation'\n          },\n          fromCity: {\n            type: 'string',\n            required: true,\n            description: 'Departure city'\n          },\n          toCity: {\n            type: 'string',\n            required: true,\n            description: 'Destination city'\n          },\n          cargo: {\n            type: 'array',\n            required: true,\n            description: 'Array of cargo items',\n            items: {\n              length: { type: 'number', required: true, description: 'Length in cm' },\n              width: { type: 'number', required: true, description: 'Width in cm' },\n              height: { type: 'number', required: true, description: 'Height in cm' },\n              weight: { type: 'number', required: true, description: 'Weight in kg' },\n              quantity: { type: 'number', optional: true, default: 1, description: 'Quantity of items' }\n            }\n          },\n          options: {\n            type: 'object',\n            optional: true,\n            description: 'Additional calculation options',\n            properties: {\n              insurance: { type: 'boolean', optional: true, description: 'Include insurance' },\n              packaging: { type: 'boolean', optional: true, description: 'Include packaging' },\n              urgent: { type: 'boolean', optional: true, description: 'Urgent delivery' }\n            }\n          }\n        },\n        responseBody: {\n          success: { type: 'boolean', description: 'Request success status' },\n          company: { type: 'string', description: 'Transport company used' },\n          calculation: {\n            type: 'object',\n            properties: {\n              totalCost: { type: 'number', description: 'Total cost in specified currency' },\n              currency: { type: 'string', description: 'Currency code (RUB, USD, etc.)' },\n              deliveryTime: {\n                type: 'object',\n                properties: {\n                  min: { type: 'number', description: 'Minimum delivery time' },\n                  max: { type: 'number', description: 'Maximum delivery time' },\n                  unit: { type: 'string', description: 'Time unit (days, hours)' }\n                }\n              },\n              breakdown: {\n                type: 'object',\n                optional: true,\n                description: 'Cost breakdown by components'\n              }\n            }\n          },\n          metadata: {\n            type: 'object',\n            properties: {\n              requestId: { type: 'string', description: 'Unique request identifier' },\n              timestamp: { type: 'string', description: 'Request timestamp' },\n              processingTime: { type: 'number', description: 'Processing time in milliseconds' }\n            }\n          },\n          error: { type: 'string', optional: true, description: 'Error message if success is false' }\n        },\n        examples: {\n          request: {\n            company: 'pek',\n            fromCity: 'Москва',\n            toCity: 'Санкт-Петербург',\n            cargo: [\n              {\n                length: 100,\n                width: 50,\n                height: 50,\n                weight: 10,\n                quantity: 2\n              }\n            ],\n            options: {\n              insurance: true\n            }\n          },\n          response: {\n            success: true,\n            company: 'pek',\n            calculation: {\n              totalCost: 2500,\n              currency: 'RUB',\n              deliveryTime: {\n                min: 2,\n                max: 3,\n                unit: 'days'\n              },\n              breakdown: {\n                baseCost: 2000,\n                insurance: 500\n              }\n            },\n            metadata: {\n              requestId: 'req_1234567890_abc123def',\n              timestamp: '2024-01-15T10:30:00.000Z',\n              processingTime: 1250\n            }\n          }\n        }\n      }\n    },\n    supportedCompanies: SUPPORTED_COMPANIES,\n    rateLimit: {\n      window: '1 minute',\n      maxRequests: RATE_LIMIT_MAX_REQUESTS,\n      headers: {\n        'X-RateLimit-Limit': 'Maximum requests per window',\n        'X-RateLimit-Remaining': 'Remaining requests in current window',\n        'X-RateLimit-Reset': 'Time when the rate limit resets (Unix timestamp)'\n      }\n    },\n    errorCodes: {\n      400: 'Bad Request - Invalid input parameters',\n      429: 'Too Many Requests - Rate limit exceeded',\n      500: 'Internal Server Error - Server-side error'\n    }\n  });\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/app/api/external/route.ts",
      "exists": false
    },
    "title": "app/api/external/route.ts",
    "time": {
      "start": 1760451586131,
      "end": 1760451586132
    }
  }
}