{
  "id": "prt_b22bc0faf001Ld3tRKXcX5Ub23",
  "sessionID": "ses_4ec400949ffekDUyPGFumLInaA",
  "messageID": "msg_b22bbeeb3002TLOQ2HH9QTEGdy",
  "type": "tool",
  "callID": "call_62575859",
  "tool": "multiedit",
  "state": {
    "status": "completed",
    "input": {
      "edits": [
        {
          "newString": "export function categorizeError(error: any, response?: Response): ErrorType {\n  if (!navigator.onLine) return ErrorType.NETWORK;\n\n  if (response) {\n    if (response.status === 429) return ErrorType.RATE_LIMIT;\n    if (response.status >= 400 && response.status < 500) return ErrorType.VALIDATION;\n    if (response.status >= 500) return ErrorType.SERVER;\n    if (response.status === 408 || response.status === 504) return ErrorType.TIMEOUT;\n  }\n\n  if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n  if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n  if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n  \n  // Handle socket connection errors\n  if (error.message?.includes('socket connection was closed')) return ErrorType.NETWORK;\n  if (error.message?.includes('connection closed unexpectedly')) return ErrorType.NETWORK;\n  if (error.message?.includes('ECONNRESET')) return ErrorType.NETWORK;\n  if (error.message?.includes('ENOTFOUND')) return ErrorType.NETWORK;\n  if (error.message?.includes('ETIMEDOUT')) return ErrorType.TIMEOUT;\n\n  return ErrorType.UNKNOWN;\n}",
          "oldString": "export function categorizeError(error: any, response?: Response): ErrorType {\n  if (!navigator.onLine) return ErrorType.NETWORK;\n\n  if (response) {\n    if (response.status === 429) return ErrorType.RATE_LIMIT;\n    if (response.status >= 400 && response.status < 500) return ErrorType.VALIDATION;\n    if (response.status >= 500) return ErrorType.SERVER;\n    if (response.status === 408 || response.status === 504) return ErrorType.TIMEOUT;\n  }\n\n  if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n  if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n  if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n\n  return ErrorType.UNKNOWN;\n}"
        }
      ],
      "filePath": "lib/error-handling.ts"
    },
    "output": "",
    "title": "lib/error-handling.ts",
    "metadata": {
      "results": [
        {
          "diagnostics": {},
          "diff": "Index: /home/user/project/lib/error-handling.ts\n===================================================================\n--- /home/user/project/lib/error-handling.ts\n+++ /home/user/project/lib/error-handling.ts\n@@ -135,8 +135,15 @@\n \n   if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n   if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n   if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n+  \n+  // Handle socket connection errors\n+  if (error.message?.includes('socket connection was closed')) return ErrorType.NETWORK;\n+  if (error.message?.includes('connection closed unexpectedly')) return ErrorType.NETWORK;\n+  if (error.message?.includes('ECONNRESET')) return ErrorType.NETWORK;\n+  if (error.message?.includes('ENOTFOUND')) return ErrorType.NETWORK;\n+  if (error.message?.includes('ETIMEDOUT')) return ErrorType.TIMEOUT;\n \n   return ErrorType.UNKNOWN;\n }\n \n",
          "filediff": {
            "file": "/home/user/project/lib/error-handling.ts",
            "before": "import { apiRequestWithTimeout } from './api-utils';\n\n// Error types for better categorization\nexport enum ErrorType {\n  NETWORK = 'NETWORK',\n  API = 'API',\n  VALIDATION = 'VALIDATION',\n  TIMEOUT = 'TIMEOUT',\n  RATE_LIMIT = 'RATE_LIMIT',\n  SERVER = 'SERVER',\n  UNKNOWN = 'UNKNOWN'\n}\n\nexport interface ErrorContext {\n  operation: string;\n  company?: string;\n  requestId?: string;\n  userId?: string;\n  timestamp: string;\n  retryCount?: number;\n  userAgent?: string;\n  url?: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n  retryableErrors: ErrorType[];\n}\n\nexport interface ErrorResult {\n  success: false;\n  error: {\n    type: ErrorType;\n    message: string;\n    userMessage: string;\n    technicalDetails?: any;\n    context: ErrorContext;\n    retryable: boolean;\n    suggestedAction?: string;\n  };\n  fallbackData?: any;\n}\n\n// Default retry configuration\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 30000, // 30 seconds\n  backoffFactor: 2,\n  retryableErrors: [ErrorType.NETWORK, ErrorType.TIMEOUT, ErrorType.SERVER, ErrorType.RATE_LIMIT]\n};\n\n// User-friendly error messages\nconst USER_MESSAGES = {\n  [ErrorType.NETWORK]: 'Проблемы с подключением к интернету. Проверьте соединение и попробуйте снова.',\n  [ErrorType.API]: 'Временные проблемы с сервисом транспортной компании. Попробуйте позже.',\n  [ErrorType.VALIDATION]: 'Проверьте правильность введенных данных.',\n  [ErrorType.TIMEOUT]: 'Сервис отвечает слишком долго. Попробуйте еще раз.',\n  [ErrorType.RATE_LIMIT]: 'Слишком много запросов. Подождите немного и попробуйте снова.',\n  [ErrorType.SERVER]: 'Временные технические проблемы. Попробуйте позже.',\n  [ErrorType.UNKNOWN]: 'Произошла неожиданная ошибка. Попробуйте еще раз.'\n};\n\n// Suggested actions for different error types\nconst SUGGESTED_ACTIONS = {\n  [ErrorType.NETWORK]: 'Проверьте интернет-соединение',\n  [ErrorType.API]: 'Попробуйте выбрать другую транспортную компанию',\n  [ErrorType.VALIDATION]: 'Проверьте корректность адресов и параметров груза',\n  [ErrorType.TIMEOUT]: 'Попробуйте упростить запрос или выбрать меньшее количество грузов',\n  [ErrorType.RATE_LIMIT]: 'Подождите 1-2 минуты перед следующим запросом',\n  [ErrorType.SERVER]: 'Свяжитесь с поддержкой если проблема persists',\n  [ErrorType.UNKNOWN]: 'Свяжитесь с поддержкой'\n};\n\n// Cache for storing successful results to provide fallbacks\nclass ResultCache {\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  set(key: string, data: any, ttlMinutes: number = 30): void {\n    const timestamp = Date.now();\n    const ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n    this.cache.set(key, { data, timestamp, ttl });\n  }\n\n  get(key: string): any | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    const now = Date.now();\n    if (now - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  // Clean up expired entries\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of Array.from(this.cache.entries())) {\n      if (now - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\nexport const resultCache = new ResultCache();\n\n// Clean up cache periodically\nif (typeof window !== 'undefined') {\n  setInterval(() => resultCache.cleanup(), 5 * 60 * 1000); // Every 5 minutes\n}\n\n/**\n * Categorize error based on response or error object\n */\nexport function categorizeError(error: any, response?: Response): ErrorType {\n  if (!navigator.onLine) return ErrorType.NETWORK;\n\n  if (response) {\n    if (response.status === 429) return ErrorType.RATE_LIMIT;\n    if (response.status >= 400 && response.status < 500) return ErrorType.VALIDATION;\n    if (response.status >= 500) return ErrorType.SERVER;\n    if (response.status === 408 || response.status === 504) return ErrorType.TIMEOUT;\n  }\n\n  if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n  if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n  if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n\n  return ErrorType.UNKNOWN;\n}\n\n/**\n * Calculate delay for exponential backoff\n */\nexport function calculateDelay(attempt: number, config: RetryConfig): number {\n  const delay = config.baseDelay * Math.pow(config.backoffFactor, attempt - 1);\n  const jitter = Math.random() * 0.1 * delay; // Add 10% jitter\n  return Math.min(delay + jitter, config.maxDelay);\n}\n\n/**\n * Sleep for specified milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute operation with retry logic and error handling\n */\nexport async function withErrorHandling<T>(\n  operation: () => Promise<T>,\n  context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n  retryConfig: Partial<RetryConfig> = {},\n  cacheKey?: string\n): Promise<T | ErrorResult> {\n  const config = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };\n  const fullContext: ErrorContext = {\n    ...context,\n    timestamp: new Date().toISOString(),\n    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n    url: typeof window !== 'undefined' ? window.location.href : undefined\n  };\n\n  // Check cache first for fallback data\n  const cachedResult = cacheKey ? resultCache.get(cacheKey) : null;\n\n  for (let attempt = 1; attempt <= config.maxRetries + 1; attempt++) {\n    try {\n      fullContext.retryCount = attempt - 1;\n      const result = await operation();\n\n      // Cache successful results\n      if (cacheKey && result) {\n        resultCache.set(cacheKey, result);\n      }\n\n      return result;\n    } catch (error: any) {\n      const errorType = categorizeError(error, error.response);\n\n      console.error(`[ErrorHandler] Attempt ${attempt}/${config.maxRetries + 1} failed:`, {\n        error: error.message,\n        type: errorType,\n        context: fullContext\n      });\n\n      // If this is the last attempt or error is not retryable\n      if (attempt > config.maxRetries || !config.retryableErrors.includes(errorType)) {\n        const errorResult: ErrorResult = {\n          success: false,\n          error: {\n            type: errorType,\n            message: error.message || 'Unknown error',\n            userMessage: USER_MESSAGES[errorType],\n            technicalDetails: process.env.NODE_ENV === 'development' ? error : undefined,\n            context: fullContext,\n            retryable: config.retryableErrors.includes(errorType),\n            suggestedAction: SUGGESTED_ACTIONS[errorType]\n          }\n        };\n\n        // Add fallback data from cache if available\n        if (cachedResult) {\n          errorResult.fallbackData = cachedResult;\n          errorResult.error.userMessage += ' Показаны последние актуальные данные.';\n        }\n\n        return errorResult;\n      }\n\n      // Wait before retrying\n      const delay = calculateDelay(attempt, config);\n      console.log(`[ErrorHandler] Retrying in ${delay}ms...`);\n      await sleep(delay);\n    }\n  }\n\n  // This should never be reached, but TypeScript requires it\n  return {\n    success: false,\n    error: {\n      type: ErrorType.UNKNOWN,\n      message: 'Unexpected error in retry logic',\n      userMessage: USER_MESSAGES[ErrorType.UNKNOWN],\n      context: fullContext,\n      retryable: false\n    }\n  };\n}\n\n/**\n * Enhanced API request with error handling and caching\n */\nexport async function apiRequestWithErrorHandling(\n  endpoint: string,\n  options: RequestInit = {},\n  context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n  retryConfig?: Partial<RetryConfig>,\n  cacheKey?: string\n): Promise<any | ErrorResult> {\n  return withErrorHandling(\n    () => apiRequestWithTimeout(endpoint, options),\n    context,\n    retryConfig,\n    cacheKey\n  );\n}\n\n/**\n * Graceful degradation helper for UI components\n * Note: This function is not currently used and would need to be moved to a .tsx file if implemented\n */\nexport function withGracefulDegradation<T>(\n  Component: React.ComponentType<T>,\n  FallbackComponent: React.ComponentType<{ error: ErrorResult }>\n) {\n  return function GracefulComponent(props: T) {\n    // This would be used in error boundaries\n    // For now, just return the original component\n    return Component;\n  };\n}\n\n// Error boundary component removed - should be implemented in a .tsx file if needed",
            "after": "import { apiRequestWithTimeout } from './api-utils';\n\n// Error types for better categorization\nexport enum ErrorType {\n  NETWORK = 'NETWORK',\n  API = 'API',\n  VALIDATION = 'VALIDATION',\n  TIMEOUT = 'TIMEOUT',\n  RATE_LIMIT = 'RATE_LIMIT',\n  SERVER = 'SERVER',\n  UNKNOWN = 'UNKNOWN'\n}\n\nexport interface ErrorContext {\n  operation: string;\n  company?: string;\n  requestId?: string;\n  userId?: string;\n  timestamp: string;\n  retryCount?: number;\n  userAgent?: string;\n  url?: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n  retryableErrors: ErrorType[];\n}\n\nexport interface ErrorResult {\n  success: false;\n  error: {\n    type: ErrorType;\n    message: string;\n    userMessage: string;\n    technicalDetails?: any;\n    context: ErrorContext;\n    retryable: boolean;\n    suggestedAction?: string;\n  };\n  fallbackData?: any;\n}\n\n// Default retry configuration\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 30000, // 30 seconds\n  backoffFactor: 2,\n  retryableErrors: [ErrorType.NETWORK, ErrorType.TIMEOUT, ErrorType.SERVER, ErrorType.RATE_LIMIT]\n};\n\n// User-friendly error messages\nconst USER_MESSAGES = {\n  [ErrorType.NETWORK]: 'Проблемы с подключением к интернету. Проверьте соединение и попробуйте снова.',\n  [ErrorType.API]: 'Временные проблемы с сервисом транспортной компании. Попробуйте позже.',\n  [ErrorType.VALIDATION]: 'Проверьте правильность введенных данных.',\n  [ErrorType.TIMEOUT]: 'Сервис отвечает слишком долго. Попробуйте еще раз.',\n  [ErrorType.RATE_LIMIT]: 'Слишком много запросов. Подождите немного и попробуйте снова.',\n  [ErrorType.SERVER]: 'Временные технические проблемы. Попробуйте позже.',\n  [ErrorType.UNKNOWN]: 'Произошла неожиданная ошибка. Попробуйте еще раз.'\n};\n\n// Suggested actions for different error types\nconst SUGGESTED_ACTIONS = {\n  [ErrorType.NETWORK]: 'Проверьте интернет-соединение',\n  [ErrorType.API]: 'Попробуйте выбрать другую транспортную компанию',\n  [ErrorType.VALIDATION]: 'Проверьте корректность адресов и параметров груза',\n  [ErrorType.TIMEOUT]: 'Попробуйте упростить запрос или выбрать меньшее количество грузов',\n  [ErrorType.RATE_LIMIT]: 'Подождите 1-2 минуты перед следующим запросом',\n  [ErrorType.SERVER]: 'Свяжитесь с поддержкой если проблема persists',\n  [ErrorType.UNKNOWN]: 'Свяжитесь с поддержкой'\n};\n\n// Cache for storing successful results to provide fallbacks\nclass ResultCache {\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  set(key: string, data: any, ttlMinutes: number = 30): void {\n    const timestamp = Date.now();\n    const ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n    this.cache.set(key, { data, timestamp, ttl });\n  }\n\n  get(key: string): any | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    const now = Date.now();\n    if (now - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  // Clean up expired entries\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of Array.from(this.cache.entries())) {\n      if (now - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\nexport const resultCache = new ResultCache();\n\n// Clean up cache periodically\nif (typeof window !== 'undefined') {\n  setInterval(() => resultCache.cleanup(), 5 * 60 * 1000); // Every 5 minutes\n}\n\n/**\n * Categorize error based on response or error object\n */\nexport function categorizeError(error: any, response?: Response): ErrorType {\n  if (!navigator.onLine) return ErrorType.NETWORK;\n\n  if (response) {\n    if (response.status === 429) return ErrorType.RATE_LIMIT;\n    if (response.status >= 400 && response.status < 500) return ErrorType.VALIDATION;\n    if (response.status >= 500) return ErrorType.SERVER;\n    if (response.status === 408 || response.status === 504) return ErrorType.TIMEOUT;\n  }\n\n  if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n  if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n  if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n  \n  // Handle socket connection errors\n  if (error.message?.includes('socket connection was closed')) return ErrorType.NETWORK;\n  if (error.message?.includes('connection closed unexpectedly')) return ErrorType.NETWORK;\n  if (error.message?.includes('ECONNRESET')) return ErrorType.NETWORK;\n  if (error.message?.includes('ENOTFOUND')) return ErrorType.NETWORK;\n  if (error.message?.includes('ETIMEDOUT')) return ErrorType.TIMEOUT;\n\n  return ErrorType.UNKNOWN;\n}\n\n/**\n * Calculate delay for exponential backoff\n */\nexport function calculateDelay(attempt: number, config: RetryConfig): number {\n  const delay = config.baseDelay * Math.pow(config.backoffFactor, attempt - 1);\n  const jitter = Math.random() * 0.1 * delay; // Add 10% jitter\n  return Math.min(delay + jitter, config.maxDelay);\n}\n\n/**\n * Sleep for specified milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute operation with retry logic and error handling\n */\nexport async function withErrorHandling<T>(\n  operation: () => Promise<T>,\n  context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n  retryConfig: Partial<RetryConfig> = {},\n  cacheKey?: string\n): Promise<T | ErrorResult> {\n  const config = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };\n  const fullContext: ErrorContext = {\n    ...context,\n    timestamp: new Date().toISOString(),\n    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n    url: typeof window !== 'undefined' ? window.location.href : undefined\n  };\n\n  // Check cache first for fallback data\n  const cachedResult = cacheKey ? resultCache.get(cacheKey) : null;\n\n  for (let attempt = 1; attempt <= config.maxRetries + 1; attempt++) {\n    try {\n      fullContext.retryCount = attempt - 1;\n      const result = await operation();\n\n      // Cache successful results\n      if (cacheKey && result) {\n        resultCache.set(cacheKey, result);\n      }\n\n      return result;\n    } catch (error: any) {\n      const errorType = categorizeError(error, error.response);\n\n      console.error(`[ErrorHandler] Attempt ${attempt}/${config.maxRetries + 1} failed:`, {\n        error: error.message,\n        type: errorType,\n        context: fullContext\n      });\n\n      // If this is the last attempt or error is not retryable\n      if (attempt > config.maxRetries || !config.retryableErrors.includes(errorType)) {\n        const errorResult: ErrorResult = {\n          success: false,\n          error: {\n            type: errorType,\n            message: error.message || 'Unknown error',\n            userMessage: USER_MESSAGES[errorType],\n            technicalDetails: process.env.NODE_ENV === 'development' ? error : undefined,\n            context: fullContext,\n            retryable: config.retryableErrors.includes(errorType),\n            suggestedAction: SUGGESTED_ACTIONS[errorType]\n          }\n        };\n\n        // Add fallback data from cache if available\n        if (cachedResult) {\n          errorResult.fallbackData = cachedResult;\n          errorResult.error.userMessage += ' Показаны последние актуальные данные.';\n        }\n\n        return errorResult;\n      }\n\n      // Wait before retrying\n      const delay = calculateDelay(attempt, config);\n      console.log(`[ErrorHandler] Retrying in ${delay}ms...`);\n      await sleep(delay);\n    }\n  }\n\n  // This should never be reached, but TypeScript requires it\n  return {\n    success: false,\n    error: {\n      type: ErrorType.UNKNOWN,\n      message: 'Unexpected error in retry logic',\n      userMessage: USER_MESSAGES[ErrorType.UNKNOWN],\n      context: fullContext,\n      retryable: false\n    }\n  };\n}\n\n/**\n * Enhanced API request with error handling and caching\n */\nexport async function apiRequestWithErrorHandling(\n  endpoint: string,\n  options: RequestInit = {},\n  context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n  retryConfig?: Partial<RetryConfig>,\n  cacheKey?: string\n): Promise<any | ErrorResult> {\n  return withErrorHandling(\n    () => apiRequestWithTimeout(endpoint, options),\n    context,\n    retryConfig,\n    cacheKey\n  );\n}\n\n/**\n * Graceful degradation helper for UI components\n * Note: This function is not currently used and would need to be moved to a .tsx file if implemented\n */\nexport function withGracefulDegradation<T>(\n  Component: React.ComponentType<T>,\n  FallbackComponent: React.ComponentType<{ error: ErrorResult }>\n) {\n  return function GracefulComponent(props: T) {\n    // This would be used in error boundaries\n    // For now, just return the original component\n    return Component;\n  };\n}\n\n// Error boundary component removed - should be implemented in a .tsx file if needed",
            "additions": 7,
            "deletions": 0
          }
        }
      ]
    },
    "time": {
      "start": 1765814308790,
      "end": 1765814308811
    }
  }
}