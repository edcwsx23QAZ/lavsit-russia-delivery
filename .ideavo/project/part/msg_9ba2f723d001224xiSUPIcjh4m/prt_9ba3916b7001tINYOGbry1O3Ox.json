{
  "type": "text",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "messageID": "msg_9ba2f723d001224xiSUPIcjh4m",
  "id": "prt_9ba3916b7001tINYOGbry1O3Ox",
  "text": "I'll implement all three solutions to ensure robust form data persistence across page reloads. Let me start by implementing each approach systematically.\n\n## 1. IndexedDB Implementation\n\nFirst, let's create an IndexedDB storage solution:\n\n<bun_run>\ncat > lib/indexeddb-storage.ts << 'EOF'\n\"use client\";\n\ninterface FormData {\n  [key: string]: any;\n}\n\nclass IndexedDBStorage {\n  private dbName = 'FormPersistenceDB';\n  private version = 1;\n  private storeName = 'formData';\n  private db: IDBDatabase | null = null;\n\n  async init(): Promise<void> {\n    if (typeof window === 'undefined') return;\n    \n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.dbName, this.version);\n      \n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n      \n      request.onupgradeneeded = (event) => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        if (!db.objectStoreNames.contains(this.storeName)) {\n          db.createObjectStore(this.storeName, { keyPath: 'id' });\n        }\n      };\n    });\n  }\n\n  async saveFormData(key: string, data: FormData): Promise<boolean> {\n    if (!this.db) await this.init();\n    if (!this.db) return false;\n\n    return new Promise((resolve) => {\n      try {\n        const transaction = this.db!.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        \n        const record = {\n          id: key,\n          data: data,\n          timestamp: Date.now()\n        };\n        \n        const request = store.put(record);\n        \n        request.onsuccess = () => {\n          console.log(`[IndexedDB] Form data saved for key: ${key}`);\n          resolve(true);\n        };\n        \n        request.onerror = () => {\n          console.error(`[IndexedDB] Failed to save form data for key: ${key}`, request.error);\n          resolve(false);\n        };\n      } catch (error) {\n        console.error(`[IndexedDB] Error saving form data:`, error);\n        resolve(false);\n      }\n    });\n  }\n\n  async getFormData(key: string): Promise<FormData | null> {\n    if (!this.db) await this.init();\n    if (!this.db) return null;\n\n    return new Promise((resolve) => {\n      try {\n        const transaction = this.db!.transaction([this.storeName], 'readonly');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.get(key);\n        \n        request.onsuccess = () => {\n          if (request.result) {\n            console.log(`[IndexedDB] Form data retrieved for key: ${key}`);\n            resolve(request.result.data);\n          } else {\n            console.log(`[IndexedDB] No form data found for key: ${key}`);\n            resolve(null);\n          }\n        };\n        \n        request.onerror = () => {\n          console.error(`[IndexedDB] Failed to retrieve form data for key: ${key}`, request.error);\n          resolve(null);\n        };\n      } catch (error) {\n        console.error(`[IndexedDB] Error retrieving form data:`, error);\n        resolve(null);\n      }\n    });\n  }\n\n  async clearFormData(key: string): Promise<boolean> {\n    if (!this.db) await this.init();\n    if (!this.db) return false;\n\n    return new Promise((resolve) => {\n      try {\n        const transaction = this.db!.transaction([this.storeName], 'readwrite');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.delete(key);\n        \n        request.onsuccess = () => {\n          console.log(`[IndexedDB] Form data cleared for key: ${key}`);\n          resolve(true);\n        };\n        \n        request.onerror = () => {\n          console.error(`[IndexedDB] Failed to clear form data for key: ${key}`, request.error);\n          resolve(false);\n        };\n      } catch (error) {\n        console.error(`[IndexedDB] Error clearing form data:`, error);\n        resolve(false);\n      }\n    });\n  }\n\n  async getAllKeys(): Promise<string[]> {\n    if (!this.db) await this.init();\n    if (!this.db) return [];\n\n    return new Promise((resolve) => {\n      try {\n        const transaction = this.db!.transaction([this.storeName], 'readonly');\n        const store = transaction.objectStore(this.storeName);\n        const request = store.getAllKeys();\n        \n        request.onsuccess = () => {\n          resolve(request.result as string[]);\n        };\n        \n        request.onerror = () => {\n          console.error('[IndexedDB] Failed to get all keys', request.error);\n          resolve([]);\n        };\n      } catch (error) {\n        console.error('[IndexedDB] Error getting all keys:', error);\n        resolve([]);\n      }\n    });\n  }\n}\n\n// Create singleton instance\nexport const indexedDBStorage = new IndexedDBStorage();\nEOF\n</bun_run>\n\n## 2. Cookie-Based Storage Implementation\n\nNow let's create a cookie-based storage solution:\n\n<bun_run>\ncat > lib/cookie-storage.ts << 'EOF'\n\"use client\";\n\ninterface FormData {\n  [key: string]: any;\n}\n\nclass CookieStorage {\n  private maxCookieSize = 4000; // Safe limit for cookie size\n  private cookiePrefix = 'form_';\n\n  private setCookie(name: string, value: string, days: number = 7): void {\n    if (typeof document === 'undefined') return;\n    \n    const expires = new Date();\n    expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);\n    \n    document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/;SameSite=Lax`;\n  }\n\n  private getCookie(name: string): string | null {\n    if (typeof document === 'undefined') return null;\n    \n    const nameEQ = name + '=';\n    const ca = document.cookie.split(';');\n    \n    for (let i = 0; i < ca.length; i++) {\n      let c = ca[i];\n      while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n      if (c.indexOf(nameEQ) === 0) {\n        return decodeURIComponent(c.substring(nameEQ.length, c.length));\n      }\n    }\n    return null;\n  }\n\n  private deleteCookie(name: string): void {\n    if (typeof document === 'undefined') return;\n    document.cookie = `${name}=;expires=Thu, 01 Jan 1970 00:00:00 UTC;path=/;`;\n  }\n\n  saveFormData(key: string, data: FormData): boolean {\n    try {\n      const serializedData = JSON.stringify(data);\n      const cookieName = `${this.cookiePrefix}${key}`;\n      \n      if (serializedData.length > this.maxCookieSize) {\n        console.warn(`[Cookie] Form data too large for cookie storage: ${serializedData.length} bytes`);\n        // Split large data into chunks\n        this.saveChunkedData(key, serializedData);\n        return true;\n      }\n      \n      this.setCookie(cookieName, serializedData);\n      console.log(`[Cookie] Form data saved for key: ${key}`);\n      return true;\n    } catch (error) {\n      console.error(`[Cookie] Error saving form data:`, error);\n      return false;\n    }\n  }\n\n  private saveChunkedData(key: string, data: string): void {\n    const chunkSize = this.maxCookieSize;\n    const chunks = [];\n    \n    for (let i = 0; i < data.length; i += chunkSize) {\n      chunks.push(data.slice(i, i + chunkSize));\n    }\n    \n    // Save chunk count\n    this.setCookie(`${this.cookiePrefix}${key}_count`, chunks.length.toString());\n    \n    // Save each chunk\n    chunks.forEach((chunk, index) => {\n      this.setCookie(`${this.cookiePrefix}${key}_${index}`, chunk);\n    });\n    \n    console.log(`[Cookie] Form data saved in ${chunks.length} chunks for key: ${key}`);\n  }\n\n  getFormData(key: string): FormData | null {\n    try {\n      const cookieName = `${this.cookiePrefix}${key}`;\n      let serializedData = this.getCookie(cookieName);\n      \n      // Check if data was chunked\n      if (!serializedData) {\n        serializedData = this.getChunkedData(key);\n      }\n      \n      if (!serializedData) {\n        console.log(`[Cookie] No form data found for key: ${key}`);\n        return null;\n      }\n      \n      const data = JSON.parse(serializedData);\n      console.log(`[Cookie] Form data retrieved for key: ${key}`);\n      return data;\n    } catch (error) {\n      console.error(`[Cookie] Error retrieving form data:`, error);\n      return null;\n    }\n  }\n\n  private getChunkedData(key: string): string | null {\n    const countCookie = this.getCookie(`${this.cookiePrefix}${key}_count`);\n    if (!countCookie) return null;\n    \n    const chunkCount = parseInt(countCookie, 10);\n    if (isNaN(chunkCount)) return null;\n    \n    let reconstructedData = '';\n    for (let i = 0; i < chunkCount; i++) {\n      const chunk = this.getCookie(`${this.cookiePrefix}${key}_${i}`);\n      if (!chunk) return null;\n      reconstructedData += chunk;\n    }\n    \n    return reconstructedData;\n  }\n\n  clearFormData(key: string): boolean {\n    try {\n      const cookieName = `${this.cookiePrefix}${key}`;\n      \n      // Clear main cookie\n      this.deleteCookie(cookieName);\n      \n      // Clear chunked data if exists\n      const countCookie = this.getCookie(`${this.cookiePrefix}${key}_count`);\n      if (countCookie) {\n        const chunkCount = parseInt(countCookie, 10);\n        if (!isNaN(chunkCount)) {\n          for (let i = 0; i < chunkCount; i++) {\n            this.deleteCookie(`${this.cookiePrefix}${key}_${i}`);\n          }\n          this.deleteCookie(`${this.cookiePrefix}${key}_count`);\n        }\n      }\n      \n      console.log(`[Cookie] Form data cleared for key: ${key}`);\n      return true;\n    } catch (error) {\n      console.error(`[Cookie] Error clearing form data:`, error);\n      return false;\n    }\n  }\n\n  getAllKeys(): string[] {\n    if (typeof document === 'undefined') return [];\n    \n    const keys = new Set<string>();\n    const cookies = document.cookie.split(';');\n    \n    cookies.forEach(cookie => {\n      const name = cookie.trim().split('=')[0];\n      if (name.startsWith(this.cookiePrefix)) {\n        const key = name.replace(this.cookiePrefix, '').split('_')[0];\n        if (key) keys.add(key);\n      }\n    });\n    \n    return Array.from(keys);\n  }\n}\n\n// Create singleton instance\nexport const cookieStorage = new CookieStorage();\nEOF\n</bun_run>\n\n## 3. Enhanced Form Guardian with All Storage Methods\n\nNow let's update the Form Guardian to use all three storage methods:\n\n<bun_run>\ncat > public/persistent-form-guardian.js << 'EOF'\n/**\n * Persistent Form Guardian - Triple-Layer Protection System\n * Protects form data from Clear-Site-Data headers using:\n * 1. Memory storage (immediate protection)\n * 2. LocalStorage backup (multiple strategies)\n * 3. IndexedDB storage (survives Clear-Site-Data)\n * 4. Cookie storage (server-accessible backup)\n */\n\n(function() {\n    'use strict';\n\n    console.log('[FORM-GUARDIAN] Initializing triple-layer protection...');\n\n    // Memory storage for immediate protection\n    let memoryStorage = {};\n\n    // Storage keys for different backup strategies\n    const STORAGE_KEYS = {\n        primary: 'formDataBackup',\n        alt1: 'fd_bkp',\n        alt2: 'form_persist',\n        alt3: 'app_form_data'\n    };\n\n    // IndexedDB setup\n    let indexedDB_instance = null;\n    const DB_NAME = 'FormPersistenceDB';\n    const DB_VERSION = 1;\n    const STORE_NAME = 'formData';\n\n    // Cookie utilities\n    function setCookie(name, value, days = 7) {\n        const expires = new Date();\n        expires.setTime(expires.getTime() + days * 24 * 60 * 60 * 1000);\n        document.cookie = `${name}=${encodeURIComponent(value)};expires=${expires.toUTCString()};path=/;SameSite=Lax`;\n    }\n\n    function getCookie(name) {\n        const nameEQ = name + '=';\n        const ca = document.cookie.split(';');\n        for (let i = 0; i < ca.length; i++) {\n            let c = ca[i];\n            while (c.charAt(0) === ' ') c = c.substring(1, c.length);\n            if (c.indexOf(nameEQ) === 0) {\n                return decodeURIComponent(c.substring(nameEQ.length, c.length));\n            }\n        }\n        return null;\n    }\n\n    // Initialize IndexedDB\n    function initIndexedDB() {\n        return new Promise((resolve, reject) => {\n            if (!window.indexedDB) {\n                console.warn('[FORM-GUARDIAN] IndexedDB not supported');\n                resolve(null);\n                return;\n            }\n\n            const request = indexedDB.open(DB_NAME, DB_VERSION);\n            \n            request.onerror = () => {\n                console.error('[FORM-GUARDIAN] IndexedDB initialization failed:', request.error);\n                resolve(null);\n            };\n            \n            request.onsuccess = () => {\n                indexedDB_instance = request.result;\n                console.log('[FORM-GUARDIAN] IndexedDB initialized successfully');\n                resolve(indexedDB_instance);\n            };\n            \n            request.onupgradeneeded = (event) => {\n                const db = event.target.result;\n                if (!db.objectStoreNames.contains(STORE_NAME)) {\n                    db.createObjectStore(STORE_NAME, { keyPath: 'id' });\n                    console.log('[FORM-GUARDIAN] IndexedDB object store created');\n                }\n            };\n        });\n    }\n\n    // Save to IndexedDB\n    function saveToIndexedDB(key, data) {\n        return new Promise((resolve) => {\n            if (!indexedDB_instance) {\n                resolve(false);\n                return;\n            }\n\n            try {\n                const transaction = indexedDB_instance.transaction([STORE_NAME], 'readwrite');\n                const store = transaction.objectStore(STORE_NAME);\n                \n                const record = {\n                    id: key,\n                    data: data,\n                    timestamp: Date.now()\n                };\n                \n                const request = store.put(record);\n                \n                request.onsuccess = () => {\n                    console.log(`[FORM-GUARDIAN] IndexedDB save success for: ${key}`",
  "time": {
    "start": 1759765927607,
    "end": 1759765927607
  }
}