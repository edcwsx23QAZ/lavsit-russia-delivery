{
  "id": "prt_9e31652c4001R6s46C4VBMJzbe",
  "messageID": "msg_9e3162186001xAC4IaHiIiOWte",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "call_68273153",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "public/sw.js",
      "content": "const CACHE_NAME = 'freight-calculator-v1.0.0';\nconst STATIC_CACHE = 'freight-static-v1.0.0';\nconst API_CACHE = 'freight-api-v1.0.0';\n\n// Static assets to cache\nconst STATIC_ASSETS = [\n  '/',\n  '/diagnostic',\n  '/env-check',\n  '/manifest.json',\n  '/favicon.ico',\n  // Add other static assets as needed\n];\n\n// API endpoints to cache (with short TTL)\nconst API_ENDPOINTS = [\n  '/api/furniture-products',\n  '/api/dellin-packages',\n  '/api/pek',\n  '/api/vozovoz',\n  '/api/rail-continent',\n  '/api/test'\n];\n\n// Install event - cache static assets\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing service worker');\n  event.waitUntil(\n    Promise.all([\n      caches.open(STATIC_CACHE).then((cache) => {\n        console.log('[SW] Caching static assets');\n        return cache.addAll(STATIC_ASSETS);\n      }),\n      self.skipWaiting()\n    ])\n  );\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating service worker');\n  event.waitUntil(\n    Promise.all([\n      caches.keys().then((cacheNames) => {\n        return Promise.all(\n          cacheNames\n            .filter((cacheName) => cacheName !== STATIC_CACHE && cacheName !== API_CACHE)\n            .map((cacheName) => {\n              console.log('[SW] Deleting old cache:', cacheName);\n              return caches.delete(cacheName);\n            })\n        );\n      }),\n      self.clients.claim()\n    ])\n  );\n});\n\n// Fetch event - handle caching strategies\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n\n  // Handle API requests with network-first strategy\n  if (API_ENDPOINTS.some(endpoint => url.pathname.startsWith(endpoint))) {\n    event.respondWith(networkFirstStrategy(request, API_CACHE));\n    return;\n  }\n\n  // Handle static assets with cache-first strategy\n  if (STATIC_ASSETS.includes(url.pathname) || request.destination === 'style' || request.destination === 'script' || request.destination === 'image') {\n    event.respondWith(cacheFirstStrategy(request, STATIC_CACHE));\n    return;\n  }\n\n  // Default network-first for everything else\n  event.respondWith(networkFirstStrategy(request));\n});\n\n// Cache-first strategy for static assets\nasync function cacheFirstStrategy(request, cacheName) {\n  try {\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    const networkResponse = await fetch(request);\n    if (networkResponse.ok && cacheName) {\n      const cache = await caches.open(cacheName);\n      cache.put(request, networkResponse.clone());\n    }\n    return networkResponse;\n  } catch (error) {\n    console.log('[SW] Cache-first failed, trying network:', error);\n    return fetch(request);\n  }\n}\n\n// Network-first strategy for dynamic content\nasync function networkFirstStrategy(request, cacheName) {\n  try {\n    const networkResponse = await fetch(request);\n\n    if (networkResponse.ok && cacheName) {\n      const cache = await caches.open(cacheName);\n      // Add timestamp for cache invalidation\n      const responseToCache = new Response(networkResponse.clone().body, {\n        status: networkResponse.status,\n        statusText: networkResponse.statusText,\n        headers: {\n          ...Object.fromEntries(networkResponse.headers.entries()),\n          'sw-cache-time': Date.now().toString()\n        }\n      });\n      cache.put(request, responseToCache);\n    }\n\n    return networkResponse;\n  } catch (error) {\n    console.log('[SW] Network failed, trying cache:', error);\n\n    const cachedResponse = await caches.match(request);\n    if (cachedResponse) {\n      return cachedResponse;\n    }\n\n    // Return offline fallback for navigation requests\n    if (request.mode === 'navigate') {\n      return caches.match('/').then(response => {\n        return response || new Response('Offline - Please check your connection', {\n          status: 503,\n          statusText: 'Service Unavailable'\n        });\n      });\n    }\n\n    throw error;\n  }\n}\n\n// Background sync for failed requests\nself.addEventListener('sync', (event) => {\n  console.log('[SW] Background sync triggered:', event.tag);\n\n  if (event.tag === 'background-sync') {\n    event.waitUntil(doBackgroundSync());\n  }\n});\n\nasync function doBackgroundSync() {\n  // Implement background sync logic here\n  console.log('[SW] Performing background sync');\n}\n\n// Push notifications (for future use)\nself.addEventListener('push', (event) => {\n  console.log('[SW] Push received:', event);\n\n  if (event.data) {\n    const data = event.data.json();\n    const options = {\n      body: data.body,\n      icon: '/icon-192x192.png',\n      badge: '/icon-192x192.png',\n      vibrate: [100, 50, 100],\n      data: data.data\n    };\n\n    event.waitUntil(\n      self.registration.showNotification(data.title, options)\n    );\n  }\n});\n\n// Notification click handler\nself.addEventListener('notificationclick', (event) => {\n  console.log('[SW] Notification clicked:', event);\n  event.notification.close();\n\n  event.waitUntil(\n    self.clients.openWindow(event.notification.data?.url || '/')\n  );\n});\n\n// Periodic background tasks (for future use)\nself.addEventListener('periodicsync', (event) => {\n  console.log('[SW] Periodic sync:', event.tag);\n\n  if (event.tag === 'update-data') {\n    event.waitUntil(updateBackgroundData());\n  }\n});\n\nasync function updateBackgroundData() {\n  // Implement periodic data updates here\n  console.log('[SW] Updating background data');\n}\n\n// Message handler for communication with main thread\nself.addEventListener('message', (event) => {\n  console.log('[SW] Message received:', event.data);\n\n  if (event.data && event.data.type === 'SKIP_WAITING') {\n    self.skipWaiting();\n  }\n\n  if (event.data && event.data.type === 'GET_CACHE_INFO') {\n    getCacheInfo().then((info) => {\n      event.ports[0].postMessage(info);\n    });\n  }\n});\n\nasync function getCacheInfo() {\n  const cacheNames = await caches.keys();\n  const info = {};\n\n  for (const cacheName of cacheNames) {\n    const cache = await caches.open(cacheName);\n    const keys = await cache.keys();\n    info[cacheName] = {\n      count: keys.length,\n      size: 'unknown' // Would need to calculate actual size\n    };\n  }\n\n  return info;\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/public/sw.js",
      "exists": true
    },
    "title": "public/sw.js",
    "time": {
      "start": 1760451515078,
      "end": 1760451515078
    }
  }
}