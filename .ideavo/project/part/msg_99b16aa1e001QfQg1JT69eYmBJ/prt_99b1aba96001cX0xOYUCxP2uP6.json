{
  "id": "prt_99b1aba96001cX0xOYUCxP2uP6",
  "messageID": "msg_99b16aa1e001QfQg1JT69eYmBJ",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01JE2nbsS3LAPjRKPKqmfWsj",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/public/sw.js",
      "content": "const CACHE_NAME = 'transport-diagnostic-v1';\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\n// Cache configuration\nconst CACHE_CONFIG = {\n  // Static assets - cache for long time\n  static: {\n    pattern: /\\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$/,\n    duration: 24 * 60 * 60 * 1000, // 24 hours\n  },\n  // API responses - cache for short time\n  api: {\n    pattern: /^\\/api\\//,\n    duration: 5 * 60 * 1000, // 5 minutes\n  },\n  // Pages - cache for medium time\n  pages: {\n    pattern: /^\\/[^.]*$/,\n    duration: 30 * 60 * 1000, // 30 minutes\n  }\n};\n\n// Install event - cache essential files\nself.addEventListener('install', (event) => {\n  console.log('[SW] Installing service worker');\n  \n  event.waitUntil(\n    caches.open(CACHE_NAME).then((cache) => {\n      console.log('[SW] Opened cache');\n      // Cache essential files during install\n      return cache.addAll([\n        '/',\n        '/diagnostic',\n        '/manifest.json'\n      ]).catch(error => {\n        console.warn('[SW] Failed to cache some files during install:', error);\n      });\n    })\n  );\n  \n  // Force activation of new service worker\n  self.skipWaiting();\n});\n\n// Activate event - clean up old caches\nself.addEventListener('activate', (event) => {\n  console.log('[SW] Activating service worker');\n  \n  event.waitUntil(\n    caches.keys().then((cacheNames) => {\n      return Promise.all(\n        cacheNames.map((cacheName) => {\n          if (cacheName !== CACHE_NAME) {\n            console.log('[SW] Deleting old cache:', cacheName);\n            return caches.delete(cacheName);\n          }\n        })\n      );\n    }).then(() => {\n      // Take control of all clients immediately\n      return self.clients.claim();\n    })\n  );\n});\n\n// Fetch event - handle requests with caching strategy\nself.addEventListener('fetch', (event) => {\n  const { request } = event;\n  const url = new URL(request.url);\n  \n  // Skip non-GET requests and external URLs\n  if (request.method !== 'GET' || !url.origin.includes(self.location.origin)) {\n    return;\n  }\n\n  // Determine caching strategy based on request type\n  const cacheStrategy = getCacheStrategy(url.pathname);\n  \n  if (!cacheStrategy) {\n    return; // Don't cache this request\n  }\n\n  event.respondWith(\n    handleRequest(request, cacheStrategy)\n  );\n});\n\n// Determine appropriate cache strategy\nfunction getCacheStrategy(pathname) {\n  if (CACHE_CONFIG.static.pattern.test(pathname)) {\n    return { ...CACHE_CONFIG.static, name: 'static' };\n  }\n  \n  if (CACHE_CONFIG.api.pattern.test(pathname)) {\n    return { ...CACHE_CONFIG.api, name: 'api' };\n  }\n  \n  if (CACHE_CONFIG.pages.pattern.test(pathname)) {\n    return { ...CACHE_CONFIG.pages, name: 'pages' };\n  }\n  \n  return null;\n}\n\n// Handle request with appropriate caching strategy\nasync function handleRequest(request, strategy) {\n  const cache = await caches.open(CACHE_NAME);\n  const cachedResponse = await cache.match(request);\n  \n  // Check if cached response is still valid\n  if (cachedResponse) {\n    const cachedDate = cachedResponse.headers.get('sw-cached-date');\n    if (cachedDate) {\n      const age = Date.now() - parseInt(cachedDate);\n      if (age < strategy.duration) {\n        console.log(`[SW] Serving from cache (${strategy.name}):`, request.url);\n        return cachedResponse;\n      } else {\n        console.log(`[SW] Cache expired (${strategy.name}):`, request.url);\n        // Remove expired cache entry\n        cache.delete(request);\n      }\n    }\n  }\n\n  try {\n    console.log(`[SW] Fetching from network (${strategy.name}):`, request.url);\n    const response = await fetch(request);\n    \n    // Only cache successful responses\n    if (response.status === 200) {\n      // Clone response and add cache timestamp\n      const responseToCache = response.clone();\n      const headers = new Headers(responseToCache.headers);\n      headers.set('sw-cached-date', Date.now().toString());\n      \n      const cachedResponse = new Response(responseToCache.body, {\n        status: responseToCache.status,\n        statusText: responseToCache.statusText,\n        headers: headers\n      });\n      \n      // Cache the response\n      cache.put(request, cachedResponse);\n      console.log(`[SW] Cached response (${strategy.name}):`, request.url);\n    }\n    \n    return response;\n  } catch (error) {\n    console.error(`[SW] Network request failed (${strategy.name}):`, request.url, error);\n    \n    // Return cached response if network fails, even if expired\n    if (cachedResponse) {\n      console.log(`[SW] Serving stale cache due to network error (${strategy.name}):`, request.url);\n      return cachedResponse;\n    }\n    \n    // Return a basic offline response for pages\n    if (strategy.name === 'pages') {\n      return new Response(\n        `<!DOCTYPE html>\n        <html>\n        <head>\n          <title>Офлайн</title>\n          <style>\n            body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #1a1a1a; color: white; }\n            .offline { max-width: 400px; margin: 0 auto; }\n            h1 { color: #f39c12; }\n          </style>\n        </head>\n        <body>\n          <div class=\"offline\">\n            <h1>Подключение отсутствует</h1>\n            <p>Страница недоступна в автономном режиме.</p>\n            <p>Проверьте подключение к интернету и попробуйте снова.</p>\n            <button onclick=\"window.location.reload()\">Попробовать снова</button>\n          </div>\n        </body>\n        </html>`,\n        { \n          headers: { 'Content-Type': 'text/html' },\n          status: 503,\n          statusText: 'Service Unavailable'\n        }\n      );\n    }\n    \n    throw error;\n  }\n}\n\n// Listen for messages from the main thread\nself.addEventListener('message', (event) => {\n  const { type, data } = event.data;\n  \n  switch (type) {\n    case 'CLEAR_CACHE':\n      clearCache().then(() => {\n        event.ports[0].postMessage({ success: true });\n      }).catch((error) => {\n        event.ports[0].postMessage({ success: false, error: error.message });\n      });\n      break;\n      \n    case 'GET_CACHE_INFO':\n      getCacheInfo().then((info) => {\n        event.ports[0].postMessage({ success: true, data: info });\n      }).catch((error) => {\n        event.ports[0].postMessage({ success: false, error: error.message });\n      });\n      break;\n  }\n});\n\n// Clear all caches\nasync function clearCache() {\n  console.log('[SW] Clearing all caches');\n  const cache = await caches.open(CACHE_NAME);\n  const keys = await cache.keys();\n  await Promise.all(keys.map(key => cache.delete(key)));\n  console.log('[SW] All caches cleared');\n}\n\n// Get cache information\nasync function getCacheInfo() {\n  const cache = await caches.open(CACHE_NAME);\n  const keys = await cache.keys();\n  \n  const info = {\n    totalEntries: keys.length,\n    entries: []\n  };\n  \n  for (const request of keys) {\n    const response = await cache.match(request);\n    const cachedDate = response?.headers.get('sw-cached-date');\n    \n    info.entries.push({\n      url: request.url,\n      method: request.method,\n      cachedDate: cachedDate ? new Date(parseInt(cachedDate)).toISOString() : null,\n      size: response?.headers.get('content-length') || 'unknown'\n    });\n  }\n  \n  return info;\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/public/sw.js",
      "exists": false
    },
    "title": "public/sw.js",
    "time": {
      "start": 1759243869141,
      "end": 1759243869142
    }
  }
}