{
  "id": "prt_a35492be9001xsoY7RqiDiztjn",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "messageID": "msg_a35491dc0001siLqwIW242ci5X",
  "type": "tool",
  "callID": "toolu_01JNQpX2jhAXZU62VSYxFbtk",
  "tool": "read",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "components/diagnostic/SentryMonitor.tsx",
      "offset": 40,
      "limit": 100
    },
    "output": "<file>\n00041| }\n00042| \n00043| export default function SentryMonitor({ className }: SentryMonitorProps) {\n00044|   const [isEnabled, setIsEnabled] = useState(false);\n00045|   const [errors, setErrors] = useState<ErrorEvent[]>([]);\n00046|   const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetric[]>([]);\n00047|   const [isCapturing, setIsCapturing] = useState(false);\n00048| \n00049|   useEffect(() => {\n00050|     // Check if Sentry is configured\n00051|     const dsn = process.env.NEXT_PUBLIC_SENTRY_DSN;\n00052|     setIsEnabled(!!dsn);\n00053| \n00054|     if (dsn) {\n00055|       // Set up error listener\n00056|       const handleError = (event: ErrorEvent) => {\n00057|         setErrors(prev => [event, ...prev.slice(0, 49)]); // Keep last 50 errors\n00058|       };\n00059| \n00060|       // Listen for unhandled errors\n00061|       window.addEventListener('error', (event) => {\n00062|         handleError({\n00063|           id: Date.now().toString(),\n00064|           timestamp: new Date().toISOString(),\n00065|           message: event.message,\n00066|           level: 'error',\n00067|           stack: event.error?.stack,\n00068|           url: window.location.href,\n00069|           userAgent: navigator.userAgent\n00070|         });\n00071|       });\n00072| \n00073|       // Listen for unhandled promise rejections\n00074|       window.addEventListener('unhandledrejection', (event) => {\n00075|         handleError({\n00076|           id: Date.now().toString(),\n00077|           timestamp: new Date().toISOString(),\n00078|           message: event.reason?.message || 'Unhandled promise rejection',\n00079|           level: 'error',\n00080|           stack: event.reason?.stack,\n00081|           url: window.location.href,\n00082|           userAgent: navigator.userAgent\n00083|         });\n00084|       });\n00085|     }\n00086|   }, []);\n00087| \n00088|   const triggerTestError = useCallback(() => {\n00089|     try {\n00090|       // Trigger a test error\n00091|       throw new Error('Test error from Sentry Monitor - this is intentional for testing');\n00092|     } catch (error) {\n00093|       Sentry.captureException(error);\n00094|       console.log('Test error sent to Sentry');\n00095|     }\n00096|   }, []);\n00097| \n00098|   const triggerTestWarning = useCallback(() => {\n00099|     // Send a test warning\n00100|     Sentry.captureMessage('Test warning from Sentry Monitor - this is intentional for testing', 'warning');\n00101|     console.log('Test warning sent to Sentry');\n00102|   }, []);\n00103| \n00104|   const triggerPerformanceCapture = useCallback(() => {\n00105|     setIsCapturing(true);\n00106| \n00107|     // Simulate performance measurement\n00108|     const startTime = performance.now();\n00109| \n00110|     setTimeout(() => {\n00111|       const endTime = performance.now();\n00112|       const duration = endTime - startTime;\n00113| \n00114|       const metric: PerformanceMetric = {\n00115|         name: 'Test Operation',\n00116|         value: duration,\n00117|         unit: 'ms',\n00118|         timestamp: new Date().toISOString()\n00119|       };\n00120| \n00121|       setPerformanceMetrics(prev => [metric, ...prev.slice(0, 49)]);\n00122| \n00123|       // Send to Sentry - TODO: Fix metrics API\n00124|       // Sentry.metrics.increment('test_operation_duration', duration, {\n00125|       //   unit: 'millisecond'\n00126|       // });\n00127| \n00128|       setIsCapturing(false);\n00129|     }, Math.random() * 1000 + 500);\n00130|   }, []);\n00131| \n00132|   const clearErrors = useCallback(() => {\n00133|     setErrors([]);\n00134|   }, []);\n00135| \n00136|   const clearMetrics = useCallback(() => {\n00137|     setPerformanceMetrics([]);\n00138|   }, []);\n00139| \n00140|   const getErrorIcon = (level: string) => {\n\n(File has more lines. Use 'offset' parameter to read beyond line 140)\n</file>",
    "title": "components/diagnostic/SentryMonitor.tsx",
    "metadata": {
      "preview": "}\n\nexport default function SentryMonitor({ className }: SentryMonitorProps) {\n  const [isEnabled, setIsEnabled] = useState(false);\n  const [errors, setErrors] = useState<ErrorEvent[]>([]);\n  const [performanceMetrics, setPerformanceMetrics] = useState<PerformanceMetric[]>([]);\n  const [isCapturing, setIsCapturing] = useState(false);\n\n  useEffect(() => {\n    // Check if Sentry is configured\n    const dsn = process.env.NEXT_PUBLIC_SENTRY_DSN;\n    setIsEnabled(!!dsn);\n\n    if (dsn) {\n      // Set up error listener\n      const handleError = (event: ErrorEvent) => {\n        setErrors(prev => [event, ...prev.slice(0, 49)]); // Keep last 50 errors\n      };\n\n      // Listen for unhandled errors"
    },
    "time": {
      "start": 1761830579641,
      "end": 1761830579653,
      "compacted": 1763403135400
    }
  }
}