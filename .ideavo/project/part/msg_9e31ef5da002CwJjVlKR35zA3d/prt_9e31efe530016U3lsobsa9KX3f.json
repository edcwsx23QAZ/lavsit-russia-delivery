{
  "id": "prt_9e31efe530016U3lsobsa9KX3f",
  "messageID": "msg_9e31ef5da002CwJjVlKR35zA3d",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "read",
  "callID": "call_34514420",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "lib/api-utils.ts"
    },
    "output": "<file>\n00001| export interface ApiRequestConfig {\n00002|   timeout?: number;\n00003|   retries?: number;\n00004|   retryDelay?: number;\n00005| }\n00006| \n00007| export class ApiTimeoutError extends Error {\n00008|   constructor(message: string, public readonly timeoutMs: number) {\n00009|     super(message);\n00010|     this.name = 'ApiTimeoutError';\n00011|   }\n00012| }\n00013| \n00014| export class ApiValidationError extends Error {\n00015|   constructor(message: string, public readonly field?: string) {\n00016|     super(message);\n00017|     this.name = 'ApiValidationError';\n00018|   }\n00019| }\n00020| \n00021| export async function apiRequestWithTimeout(\n00022|   url: string,\n00023|   options: RequestInit = {},\n00024|   config: ApiRequestConfig = {}\n00025| ): Promise<Response> {\n00026|   const { timeout = 10000, retries = 1, retryDelay = 1000 } = config;\n00027|   \n00028|   const controller = new AbortController();\n00029|   const timeoutId = setTimeout(() => controller.abort(), timeout);\n00030|   \n00031|   const requestOptions: RequestInit = {\n00032|     ...options,\n00033|     signal: controller.signal,\n00034|   };\n00035| \n00036|   for (let attempt = 0; attempt <= retries; attempt++) {\n00037|     try {\n00038|       const response = await fetch(url, requestOptions);\n00039|       clearTimeout(timeoutId);\n00040|       return response;\n00041|     } catch (error) {\n00042|       clearTimeout(timeoutId);\n00043|       \n00044|       if (error instanceof Error && error.name === 'AbortError') {\n00045|         throw new ApiTimeoutError(`Request timeout after ${timeout}ms`, timeout);\n00046|       }\n00047|       \n00048|       if (attempt === retries) {\n00049|         throw error;\n00050|       }\n00051|       \n00052|       // Wait before retry\n00053|       await new Promise(resolve => setTimeout(resolve, retryDelay));\n00054|     }\n00055|   }\n00056|   \n00057|   throw new Error('Max retries exceeded');\n00058| }\n00059| \n00060| export function validateApiInput(data: any, rules: Record<string, (value: any) => string | null>): void {\n00061|   for (const [field, validator] of Object.entries(rules)) {\n00062|     const error = validator(data[field]);\n00063|     if (error) {\n00064|       throw new ApiValidationError(error, field);\n00065|     }\n00066|   }\n00067| }\n00068| \n00069| // Common validation rules\n00070| export const validationRules = {\n00071|   required: (field: string) => (value: any) => \n00072|     value == null || value === '' ? `${field} is required` : null,\n00073|   \n00074|   minLength: (field: string, min: number) => (value: string) =>\n00075|     value && value.length < min ? `${field} must be at least ${min} characters` : null,\n00076|   \n00077|   maxLength: (field: string, max: number) => (value: string) =>\n00078|     value && value.length > max ? `${field} must be less than ${max} characters` : null,\n00079|   \n00080|   number: (field: string) => (value: any) =>\n00081|     value != null && isNaN(Number(value)) ? `${field} must be a number` : null,\n00082|   \n00083|   positive: (field: string) => (value: number) =>\n00084|     value != null && value <= 0 ? `${field} must be positive` : null,\n00085|   \n00086|   email: (field: string) => (value: string) =>\n00087|     value && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) ? `${field} must be a valid email` : null,\n00088| };\n00089| \n00090| // Performance monitoring utilities\n00091| export class PerformanceMonitor {\n00092|   private static measurements: Map<string, number[]> = new Map();\n00093|   \n00094|   static startMeasurement(key: string): () => number {\n00095|     const start = performance.now();\n00096|     return () => {\n00097|       const duration = performance.now() - start;\n00098|       this.recordMeasurement(key, duration);\n00099|       return duration;\n00100|     };\n00101|   }\n00102|   \n00103|   static recordMeasurement(key: string, duration: number): void {\n00104|     if (!this.measurements.has(key)) {\n00105|       this.measurements.set(key, []);\n00106|     }\n00107|     const measurements = this.measurements.get(key)!;\n00108|     measurements.push(duration);\n00109|     \n00110|     // Keep only last 100 measurements to prevent memory leaks\n00111|     if (measurements.length > 100) {\n00112|       measurements.shift();\n00113|     }\n00114|   }\n00115|   \n00116|   static getAverageTime(key: string): number {\n00117|     const measurements = this.measurements.get(key) || [];\n00118|     if (measurements.length === 0) return 0;\n00119|     return measurements.reduce((sum, time) => sum + time, 0) / measurements.length;\n00120|   }\n00121|   \n00122|   static getMetrics(): Record<string, { average: number; count: number; latest: number }> {\n00123|     const metrics: Record<string, { average: number; count: number; latest: number }> = {};\n00124|     \n00125|     this.measurements.forEach((measurements, key) => {\n00126|       if (measurements.length > 0) {\n00127|         const average = measurements.reduce((sum, time) => sum + time, 0) / measurements.length;\n00128|         metrics[key] = {\n00129|           average: Math.round(average * 100) / 100,\n00130|           count: measurements.length,\n00131|           latest: Math.round(measurements[measurements.length - 1] * 100) / 100,\n00132|         };\n00133|       }\n00134|     });\n00135|     \n00136|     return metrics;\n00137|   }\n00138|   \n00139|   static clearMetrics(): void {\n00140|     this.measurements.clear();\n00141|   }\n00142| }\n</file>",
    "metadata": {
      "preview": "export interface ApiRequestConfig {\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n}\n\nexport class ApiTimeoutError extends Error {\n  constructor(message: string, public readonly timeoutMs: number) {\n    super(message);\n    this.name = 'ApiTimeoutError';\n  }\n}\n\nexport class ApiValidationError extends Error {\n  constructor(message: string, public readonly field?: string) {\n    super(message);\n    this.name = 'ApiValidationError';\n  }\n}\n"
    },
    "title": "lib/api-utils.ts",
    "time": {
      "start": 1760452083286,
      "end": 1760452083289
    }
  }
}