{
  "id": "prt_9b8f75e0b001BJ7WIqRUPyqO1d",
  "messageID": "msg_9b8f6f730001zBSaBFyyaq058T",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "read",
  "callID": "toolu_01DuKiRvftNHRBxeefKtueHy",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/public/sw.js"
    },
    "output": "<file>\n00001| const CACHE_NAME = 'transport-diagnostic-v1';\n00002| const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n00003| \n00004| // Cache configuration\n00005| const CACHE_CONFIG = {\n00006|   // Static assets - cache for long time\n00007|   static: {\n00008|     pattern: /\\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$/,\n00009|     duration: 24 * 60 * 60 * 1000, // 24 hours\n00010|   },\n00011|   // API responses - cache for short time\n00012|   api: {\n00013|     pattern: /^\\/api\\//,\n00014|     duration: 5 * 60 * 1000, // 5 minutes\n00015|   },\n00016|   // Pages - cache for medium time\n00017|   pages: {\n00018|     pattern: /^\\/[^.]*$/,\n00019|     duration: 30 * 60 * 1000, // 30 minutes\n00020|   }\n00021| };\n00022| \n00023| // Install event - cache essential files\n00024| self.addEventListener('install', (event) => {\n00025|   console.log('[SW] Installing service worker');\n00026|   \n00027|   event.waitUntil(\n00028|     caches.open(CACHE_NAME).then((cache) => {\n00029|       console.log('[SW] Opened cache');\n00030|       // Cache essential files during install\n00031|       return cache.addAll([\n00032|         '/',\n00033|         '/diagnostic',\n00034|         '/manifest.json'\n00035|       ]).catch(error => {\n00036|         console.warn('[SW] Failed to cache some files during install:', error);\n00037|       });\n00038|     })\n00039|   );\n00040|   \n00041|   // Force activation of new service worker\n00042|   self.skipWaiting();\n00043| });\n00044| \n00045| // Activate event - clean up old caches\n00046| self.addEventListener('activate', (event) => {\n00047|   console.log('[SW] Activating service worker');\n00048|   \n00049|   event.waitUntil(\n00050|     caches.keys().then((cacheNames) => {\n00051|       return Promise.all(\n00052|         cacheNames.map((cacheName) => {\n00053|           if (cacheName !== CACHE_NAME) {\n00054|             console.log('[SW] Deleting old cache:', cacheName);\n00055|             return caches.delete(cacheName);\n00056|           }\n00057|         })\n00058|       );\n00059|     }).then(() => {\n00060|       // Take control of all clients immediately\n00061|       return self.clients.claim();\n00062|     })\n00063|   );\n00064| });\n00065| \n00066| // Fetch event - handle requests with caching strategy\n00067| self.addEventListener('fetch', (event) => {\n00068|   const { request } = event;\n00069|   const url = new URL(request.url);\n00070|   \n00071|   // Skip non-GET requests and external URLs\n00072|   if (request.method !== 'GET' || !url.origin.includes(self.location.origin)) {\n00073|     return;\n00074|   }\n00075| \n00076|   // Determine caching strategy based on request type\n00077|   const cacheStrategy = getCacheStrategy(url.pathname);\n00078|   \n00079|   if (!cacheStrategy) {\n00080|     return; // Don't cache this request\n00081|   }\n00082| \n00083|   event.respondWith(\n00084|     handleRequest(request, cacheStrategy)\n00085|   );\n00086| });\n00087| \n00088| // Determine appropriate cache strategy\n00089| function getCacheStrategy(pathname) {\n00090|   if (CACHE_CONFIG.static.pattern.test(pathname)) {\n00091|     return { ...CACHE_CONFIG.static, name: 'static' };\n00092|   }\n00093|   \n00094|   if (CACHE_CONFIG.api.pattern.test(pathname)) {\n00095|     return { ...CACHE_CONFIG.api, name: 'api' };\n00096|   }\n00097|   \n00098|   if (CACHE_CONFIG.pages.pattern.test(pathname)) {\n00099|     return { ...CACHE_CONFIG.pages, name: 'pages' };\n00100|   }\n00101|   \n00102|   return null;\n00103| }\n00104| \n00105| // Handle request with appropriate caching strategy\n00106| async function handleRequest(request, strategy) {\n00107|   const cache = await caches.open(CACHE_NAME);\n00108|   const cachedResponse = await cache.match(request);\n00109|   \n00110|   // Check if cached response is still valid\n00111|   if (cachedResponse) {\n00112|     const cachedDate = cachedResponse.headers.get('sw-cached-date');\n00113|     if (cachedDate) {\n00114|       const age = Date.now() - parseInt(cachedDate);\n00115|       if (age < strategy.duration) {\n00116|         console.log(`[SW] Serving from cache (${strategy.name}):`, request.url);\n00117|         return cachedResponse;\n00118|       } else {\n00119|         console.log(`[SW] Cache expired (${strategy.name}):`, request.url);\n00120|         // Remove expired cache entry\n00121|         cache.delete(request);\n00122|       }\n00123|     }\n00124|   }\n00125| \n00126|   try {\n00127|     console.log(`[SW] Fetching from network (${strategy.name}):`, request.url);\n00128|     const response = await fetch(request);\n00129|     \n00130|     // Only cache successful responses\n00131|     if (response.status === 200) {\n00132|       // Clone response and add cache timestamp\n00133|       const responseToCache = response.clone();\n00134|       const headers = new Headers(responseToCache.headers);\n00135|       headers.set('sw-cached-date', Date.now().toString());\n00136|       \n00137|       const cachedResponse = new Response(responseToCache.body, {\n00138|         status: responseToCache.status,\n00139|         statusText: responseToCache.statusText,\n00140|         headers: headers\n00141|       });\n00142|       \n00143|       // Cache the response\n00144|       cache.put(request, cachedResponse);\n00145|       console.log(`[SW] Cached response (${strategy.name}):`, request.url);\n00146|     }\n00147|     \n00148|     return response;\n00149|   } catch (error) {\n00150|     console.error(`[SW] Network request failed (${strategy.name}):`, request.url, error);\n00151|     \n00152|     // Return cached response if network fails, even if expired\n00153|     if (cachedResponse) {\n00154|       console.log(`[SW] Serving stale cache due to network error (${strategy.name}):`, request.url);\n00155|       return cachedResponse;\n00156|     }\n00157|     \n00158|     // Return a basic offline response for pages\n00159|     if (strategy.name === 'pages') {\n00160|       return new Response(\n00161|         `<!DOCTYPE html>\n00162|         <html>\n00163|         <head>\n00164|           <title>Офлайн</title>\n00165|           <style>\n00166|             body { font-family: Arial, sans-serif; text-align: center; padding: 50px; background: #1a1a1a; color: white; }\n00167|             .offline { max-width: 400px; margin: 0 auto; }\n00168|             h1 { color: #f39c12; }\n00169|           </style>\n00170|         </head>\n00171|         <body>\n00172|           <div class=\"offline\">\n00173|             <h1>Подключение отсутствует</h1>\n00174|             <p>Страница недоступна в автономном режиме.</p>\n00175|             <p>Проверьте подключение к интернету и попробуйте снова.</p>\n00176|             <button onclick=\"window.location.reload()\">Попробовать снова</button>\n00177|           </div>\n00178|         </body>\n00179|         </html>`,\n00180|         { \n00181|           headers: { 'Content-Type': 'text/html' },\n00182|           status: 503,\n00183|           statusText: 'Service Unavailable'\n00184|         }\n00185|       );\n00186|     }\n00187|     \n00188|     throw error;\n00189|   }\n00190| }\n00191| \n00192| // Listen for messages from the main thread\n00193| self.addEventListener('message', (event) => {\n00194|   const { type, data } = event.data;\n00195|   \n00196|   switch (type) {\n00197|     case 'CLEAR_CACHE':\n00198|       clearCache().then(() => {\n00199|         event.ports[0].postMessage({ success: true });\n00200|       }).catch((error) => {\n00201|         event.ports[0].postMessage({ success: false, error: error.message });\n00202|       });\n00203|       break;\n00204|       \n00205|     case 'GET_CACHE_INFO':\n00206|       getCacheInfo().then((info) => {\n00207|         event.ports[0].postMessage({ success: true, data: info });\n00208|       }).catch((error) => {\n00209|         event.ports[0].postMessage({ success: false, error: error.message });\n00210|       });\n00211|       break;\n00212|   }\n00213| });\n00214| \n00215| // Clear all caches\n00216| async function clearCache() {\n00217|   console.log('[SW] Clearing all caches');\n00218|   const cache = await caches.open(CACHE_NAME);\n00219|   const keys = await cache.keys();\n00220|   await Promise.all(keys.map(key => cache.delete(key)));\n00221|   console.log('[SW] All caches cleared');\n00222| }\n00223| \n00224| // Get cache information\n00225| async function getCacheInfo() {\n00226|   const cache = await caches.open(CACHE_NAME);\n00227|   const keys = await cache.keys();\n00228|   \n00229|   const info = {\n00230|     totalEntries: keys.length,\n00231|     entries: []\n00232|   };\n00233|   \n00234|   for (const request of keys) {\n00235|     const response = await cache.match(request);\n00236|     const cachedDate = response?.headers.get('sw-cached-date');\n00237|     \n00238|     info.entries.push({\n00239|       url: request.url,\n00240|       method: request.method,\n00241|       cachedDate: cachedDate ? new Date(parseInt(cachedDate)).toISOString() : null,\n00242|       size: response?.headers.get('content-length') || 'unknown'\n00243|     });\n00244|   }\n00245|   \n00246|   return info;\n00247| }\n</file>",
    "metadata": {
      "preview": "const CACHE_NAME = 'transport-diagnostic-v1';\nconst CACHE_DURATION = 5 * 60 * 1000; // 5 minutes\n\n// Cache configuration\nconst CACHE_CONFIG = {\n  // Static assets - cache for long time\n  static: {\n    pattern: /\\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$/,\n    duration: 24 * 60 * 60 * 1000, // 24 hours\n  },\n  // API responses - cache for short time\n  api: {\n    pattern: /^\\/api\\//,\n    duration: 5 * 60 * 1000, // 5 minutes\n  },\n  // Pages - cache for medium time\n  pages: {\n    pattern: /^\\/[^.]*$/,\n    duration: 30 * 60 * 1000, // 30 minutes\n  }"
    },
    "title": "public/sw.js",
    "time": {
      "start": 1759744843572,
      "end": 1759744843574
    }
  }
}