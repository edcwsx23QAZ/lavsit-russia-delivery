{
  "id": "prt_994b1b206001wwdwYs4yRE37zK",
  "messageID": "msg_994af0ade001eZFeIj9XDJ123G",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "multiedit",
  "callID": "toolu_01RRrWjgf8vRJAC22GwP4HGH",
  "state": {
    "status": "error",
    "input": {
      "filePath": "/home/user/project/components/TruckVisualization.tsx",
      "edits": [
        {
          "oldString": "'use client';\n\nimport React, { useState } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Truck, RotateCcw, RotateCw } from 'lucide-react';",
          "newString": "'use client';\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Slider } from '@/components/ui/slider';\nimport { Truck, RotateCcw, RotateCw, Move, RotateCw as Rotate3d } from 'lucide-react';"
        },
        {
          "oldString": "export default function TruckVisualization({ cargos, isVisible = false }: TruckVisualizationProps) {\n  const [rotationAngle, setRotationAngle] = useState(0); // Угол поворота в градусах",
          "newString": "export default function TruckVisualization({ cargos, isVisible = false }: TruckVisualizationProps) {\n  // Состояние для 3D трансформаций\n  const [rotationX, setRotationX] = useState(15); // Поворот по оси X (наклон)\n  const [rotationY, setRotationY] = useState(25); // Поворот по оси Y (горизонтальный)\n  const [rotationZ, setRotationZ] = useState(0);  // Поворот по оси Z\n  const [positionX, setPositionX] = useState(50); // Позиция по X (0-100%)\n  const [positionY, setPositionY] = useState(50); // Позиция по Y (0-100%)\n  const [scale, setScale] = useState(50); // Масштаб (0-100%)\n  \n  // Состояние джойстика\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const joystickRef = useRef<SVGSVGElement>(null);"
        },
        {
          "oldString": "  // Вычисление проекционных вершин для 3D отображения\n  const calculateProjectedVertices = (placement: CargoPlacement) => {\n    const { x, y, z, orientation } = placement;\n    const angle = orientation.rotationAngle * Math.PI / 180;\n    \n    // Основные вершины параллелепипеда\n    const vertices3D = [\n      [x, y, z],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z],\n      // Верхние вершины\n      [x, y, z + orientation.height],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z + orientation.height],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z + orientation.height],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z + orientation.height]\n    ];\n\n    // Применяем поворот камеры\n    const cameraAngle = rotationAngle * Math.PI / 180;\n    const rotatedVertices = vertices3D.map(([x3d, y3d, z3d]) => {\n      const rotX = x3d * Math.cos(cameraAngle) - y3d * Math.sin(cameraAngle);\n      const rotY = x3d * Math.sin(cameraAngle) + y3d * Math.cos(cameraAngle);\n      return [rotX, rotY, z3d];\n    });\n\n    // Изометрическая проекция с центрированием\n    return rotatedVertices.map(([x3d, y3d, z3d]) => {\n      const scale = 0.08; // Масштаб для отображения\n      const svgWidth = 600;\n      const svgHeight = 400;\n      const offsetX = svgWidth / 2; // Центрируем по горизонтали\n      const offsetY = svgHeight * 0.75; // Смещаем вниз для лучшего вида\n      \n      // Изометрия: поворот на 45° по Y, потом наклон на 30°\n      const projX = (x3d - y3d) * Math.cos(Math.PI / 6) * scale + offsetX;\n      const projY = offsetY - ((x3d + y3d) * Math.sin(Math.PI / 6) + z3d) * scale;\n      \n      return { x: projX, y: projY };\n    });\n  };\n\n  // Вычисление вершин кузова с учетом поворота\n  const calculateTruckVertices = () => {\n    const vertices3D = [\n      // Нижние вершины кузова\n      [0, 0, 0],\n      [TRUCK_DIMENSIONS.length, 0, 0],\n      [TRUCK_DIMENSIONS.length, TRUCK_DIMENSIONS.width, 0],\n      [0, TRUCK_DIMENSIONS.width, 0],\n      // Верхние вершины кузова\n      [0, 0, TRUCK_DIMENSIONS.height],\n      [TRUCK_DIMENSIONS.length, 0, TRUCK_DIMENSIONS.height],\n      [TRUCK_DIMENSIONS.length, TRUCK_DIMENSIONS.width, TRUCK_DIMENSIONS.height],\n      [0, TRUCK_DIMENSIONS.width, TRUCK_DIMENSIONS.height]\n    ];\n\n    // Применяем поворот камеры\n    const cameraAngle = rotationAngle * Math.PI / 180;\n    const rotatedVertices = vertices3D.map(([x3d, y3d, z3d]) => {\n      const rotX = x3d * Math.cos(cameraAngle) - y3d * Math.sin(cameraAngle);\n      const rotY = x3d * Math.sin(cameraAngle) + y3d * Math.cos(cameraAngle);\n      return [rotX, rotY, z3d];\n    });\n\n    // Изометрическая проекция с центрированием\n    return rotatedVertices.map(([x3d, y3d, z3d]) => {\n      const scale = 0.08;\n      const svgWidth = 600;\n      const svgHeight = 400;\n      const offsetX = svgWidth / 2;\n      const offsetY = svgHeight * 0.75;\n      \n      const projX = (x3d - y3d) * Math.cos(Math.PI / 6) * scale + offsetX;\n      const projY = offsetY - ((x3d + y3d) * Math.sin(Math.PI / 6) + z3d) * scale;\n      \n      return { x: projX, y: projY };\n    });\n  };",
          "newString": "  // 3D матричные трансформации\n  const applyRotations = (vertices: number[][]) => {\n    const radX = (rotationX * Math.PI) / 180;\n    const radY = (rotationY * Math.PI) / 180;\n    const radZ = (rotationZ * Math.PI) / 180;\n\n    return vertices.map(([x, y, z]) => {\n      // Поворот по оси X\n      let newY = y * Math.cos(radX) - z * Math.sin(radX);\n      let newZ = y * Math.sin(radX) + z * Math.cos(radX);\n      y = newY;\n      z = newZ;\n\n      // Поворот по оси Y\n      let newX = x * Math.cos(radY) + z * Math.sin(radY);\n      newZ = -x * Math.sin(radY) + z * Math.cos(radY);\n      x = newX;\n      z = newZ;\n\n      // Поворот по оси Z\n      newX = x * Math.cos(radZ) - y * Math.sin(radZ);\n      newY = x * Math.sin(radZ) + y * Math.cos(radZ);\n      \n      return [newX, newY, newZ];\n    });\n  };\n\n  // Проекция 3D точек на 2D плоскость с учетом позиции и масштаба\n  const project3DTo2D = (vertices: number[][]) => {\n    const currentScale = (scale / 100) * 0.15; // Базовый масштаб\n    const svgWidth = 600;\n    const svgHeight = 400;\n    const offsetX = (positionX / 100) * svgWidth;\n    const offsetY = (positionY / 100) * svgHeight;\n    \n    return vertices.map(([x, y, z]) => {\n      // Простая ортогональная проекция с перспективой\n      const perspective = 1 + z * 0.0001;\n      const projX = (x * currentScale / perspective) + offsetX;\n      const projY = offsetY - (y * currentScale / perspective) - (z * currentScale * 0.7 / perspective);\n      \n      return { x: projX, y: projY };\n    });\n  };\n\n  // Вычисление проекционных вершин для 3D отображения грузов\n  const calculateProjectedVertices = (placement: CargoPlacement) => {\n    const { x, y, z, orientation } = placement;\n    const angle = orientation.rotationAngle * Math.PI / 180;\n    \n    // Основные вершины параллелепипеда\n    const vertices3D = [\n      [x, y, z],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z],\n      // Верхние вершины\n      [x, y, z + orientation.height],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z + orientation.height],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z + orientation.height],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z + orientation.height]\n    ];\n\n    // Применяем 3D повороты и проекцию\n    const rotatedVertices = applyRotations(vertices3D);\n    return project3DTo2D(rotatedVertices);\n  };\n\n  // Вычисление вершин кузова\n  const calculateTruckVertices = () => {\n    const vertices3D = [\n      // Нижние вершины кузова\n      [0, 0, 0],\n      [TRUCK_DIMENSIONS.length, 0, 0],\n      [TRUCK_DIMENSIONS.length, TRUCK_DIMENSIONS.width, 0],\n      [0, TRUCK_DIMENSIONS.width, 0],\n      // Верхние вершины кузова\n      [0, 0, TRUCK_DIMENSIONS.height],\n      [TRUCK_DIMENSIONS.length, 0, TRUCK_DIMENSIONS.height],\n      [TRUCK_DIMENSIONS.length, TRUCK_DIMENSIONS.width, TRUCK_DIMENSIONS.height],\n      [0, TRUCK_DIMENSIONS.width, TRUCK_DIMENSIONS.height]\n    ];\n\n    const rotatedVertices = applyRotations(vertices3D);\n    return project3DTo2D(rotatedVertices);\n  };\n\n  // Вычисление вершин кабины и шасси\n  const calculateCabinAndChassisVertices = () => {\n    const cabinLength = 2000; // 2 метра\n    const cabinHeight = 2500; // 2.5 метра  \n    const cabinWidth = TRUCK_DIMENSIONS.width;\n    const chassisHeight = 300; // Высота шасси\n    \n    // Кабина (впереди кузова)\n    const cabinVertices = [\n      // Нижние вершины кабины\n      [-cabinLength, 0, 0],\n      [0, 0, 0],\n      [0, cabinWidth, 0],\n      [-cabinLength, cabinWidth, 0],\n      // Верхние вершины кабины\n      [-cabinLength, 0, cabinHeight],\n      [0, 0, cabinHeight],\n      [0, cabinWidth, cabinHeight],\n      [-cabinLength, cabinWidth, cabinHeight]\n    ];\n\n    // Шасси (под кабиной и кузовом)\n    const chassisVertices = [\n      // Шасси под кабиной\n      [-cabinLength, cabinWidth * 0.2, -chassisHeight],\n      [0, cabinWidth * 0.2, -chassisHeight],\n      [0, cabinWidth * 0.8, -chassisHeight],\n      [-cabinLength, cabinWidth * 0.8, -chassisHeight],\n      // Шасси под кузовом\n      [0, cabinWidth * 0.2, -chassisHeight],\n      [TRUCK_DIMENSIONS.length, cabinWidth * 0.2, -chassisHeight],\n      [TRUCK_DIMENSIONS.length, cabinWidth * 0.8, -chassisHeight],\n      [0, cabinWidth * 0.8, -chassisHeight]\n    ];\n\n    // Колеса\n    const wheelRadius = 200;\n    const wheelVertices = [\n      // Передние колеса\n      [-cabinLength * 0.8, 0, -chassisHeight],\n      [-cabinLength * 0.8, cabinWidth, -chassisHeight],\n      // Задние колеса\n      [TRUCK_DIMENSIONS.length * 0.8, 0, -chassisHeight],\n      [TRUCK_DIMENSIONS.length * 0.8, cabinWidth, -chassisHeight]\n    ];\n\n    const rotatedCabin = applyRotations(cabinVertices);\n    const rotatedChassis = applyRotations(chassisVertices);\n    const rotatedWheels = applyRotations(wheelVertices);\n    \n    return {\n      cabin: project3DTo2D(rotatedCabin),\n      chassis: project3DTo2D(rotatedChassis),\n      wheels: project3DTo2D(rotatedWheels),\n      wheelRadius: wheelRadius * (scale / 100) * 0.15\n    };\n  };\n\n  // Обработчики джойстика\n  const handleJoystickStart = (event: React.MouseEvent<SVGSVGElement>) => {\n    setIsDragging(true);\n    const rect = joystickRef.current?.getBoundingClientRect();\n    if (rect) {\n      setDragStart({\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top\n      });\n    }\n  };\n\n  const handleJoystickMove = (event: React.MouseEvent<SVGSVGElement>) => {\n    if (!isDragging || !joystickRef.current) return;\n    \n    const rect = joystickRef.current.getBoundingClientRect();\n    const centerX = rect.width / 2;\n    const centerY = rect.height / 2;\n    const currentX = event.clientX - rect.left;\n    const currentY = event.clientY - rect.top;\n    \n    const deltaX = (currentX - centerX) / centerX; // -1 до 1\n    const deltaY = (currentY - centerY) / centerY; // -1 до 1\n    \n    // Плавное обновление углов поворота\n    setRotationY(prev => Math.max(-90, Math.min(90, prev + deltaX * 2)));\n    setRotationX(prev => Math.max(-90, Math.min(90, prev + deltaY * 2)));\n  };\n\n  const handleJoystickEnd = () => {\n    setIsDragging(false);\n  };\n\n  // Эффект для обработки движения мыши вне джойстика\n  useEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      if (isDragging && joystickRef.current) {\n        const rect = joystickRef.current.getBoundingClientRect();\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const currentX = event.clientX - rect.left;\n        const currentY = event.clientY - rect.top;\n        \n        const deltaX = (currentX - centerX) / centerX;\n        const deltaY = (currentY - centerY) / centerY;\n        \n        setRotationY(prev => Math.max(-90, Math.min(90, prev + deltaX * 2)));\n        setRotationX(prev => Math.max(-90, Math.min(90, prev + deltaY * 2)));\n      }\n    };\n\n    const handleMouseUp = () => {\n      setIsDragging(false);\n    };\n\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    }\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [isDragging]);"
        },
        {
          "oldString": "  const stats = calculateStats();\n  const truckVertices = calculateTruckVertices();\n\n  if (!isVisible) return null;",
          "newString": "  const stats = calculateStats();\n  const truckVertices = calculateTruckVertices();\n  const truckComponents = calculateCabinAndChassisVertices();\n\n  if (!isVisible) return null;"
        },
        {
          "oldString": "          <CardTitle className=\"text-white flex items-center gap-2 text-lg\">\n            <Truck className=\"h-4 w-4\" />\n            3D Визуализация размещения в кузове (вид сзади 3/4)\n          </CardTitle>",
          "newString": "          <CardTitle className=\"text-white flex items-center gap-2 text-lg\">\n            <Truck className=\"h-4 w-4\" />\n            Интерактивная 3D визуализация грузовика с размещением груза\n          </CardTitle>"
        }
      ]
    },
    "error": "Error: You must read the file /home/user/project/components/TruckVisualization.tsx before overwriting it. Use the Read tool first",
    "time": {
      "start": 1759136388349,
      "end": 1759136388351
    }
  }
}