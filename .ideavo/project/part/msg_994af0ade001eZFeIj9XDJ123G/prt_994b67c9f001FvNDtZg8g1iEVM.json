{
  "id": "prt_994b67c9f001FvNDtZg8g1iEVM",
  "messageID": "msg_994af0ade001eZFeIj9XDJ123G",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01XYFPJEvLASbTvWXJSoxous",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/TruckVisualization.tsx",
      "content": "'use client';\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Slider } from '@/components/ui/slider';\nimport { Truck, Move, RotateCw as Rotate3d } from 'lucide-react';\n\ninterface Cargo {\n  id: string;\n  length: number; // в мм\n  width: number;  // в мм\n  height: number; // в мм\n  weight: number;\n  productName?: string;\n}\n\ninterface Orientation {\n  length: number;\n  width: number;\n  height: number;\n  rotationAngle: number; // в градусах\n  flipped: boolean; // перевернут ли груз по высоте\n}\n\ninterface CargoPlacement {\n  cargo: Cargo;\n  x: number;\n  y: number;\n  z: number;\n  orientation: Orientation;\n  color: string;\n  projectedVertices: Array<{x: number, y: number}>; // Для 3D отображения\n}\n\ninterface TruckVisualizationProps {\n  cargos: Cargo[];\n  isVisible?: boolean;\n}\n\n// Размеры кузова в мм\nconst TRUCK_DIMENSIONS = {\n  length: 4200,\n  width: 2025,\n  height: 2025\n};\n\n// Углы поворота для размещения грузов (в градусах)\nconst ROTATION_ANGLES = [0, 45, 90, 135, 180, 225, 270, 315];\n\n// Цвета для разных грузов\nconst CARGO_COLORS = [\n  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',\n  '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43',\n  '#10AC84', '#EE5A24', '#0984E3', '#6C5CE7', '#FD79A8'\n];\n\nexport default function TruckVisualization({ cargos, isVisible = false }: TruckVisualizationProps) {\n  // Состояние для 3D трансформаций\n  const [rotationX, setRotationX] = useState(15); // Поворот по оси X (наклон)\n  const [rotationY, setRotationY] = useState(25); // Поворот по оси Y (горизонтальный)\n  const [rotationZ, setRotationZ] = useState(0);  // Поворот по оси Z\n  const [positionX, setPositionX] = useState(50); // Позиция по X (0-100%)\n  const [positionY, setPositionY] = useState(50); // Позиция по Y (0-100%)\n  const [scale, setScale] = useState(50); // Масштаб (0-100%)\n  \n  // Состояние джойстика\n  const [isDragging, setIsDragging] = useState(false);\n  const [dragStart, setDragStart] = useState({ x: 0, y: 0 });\n  const joystickRef = useRef<SVGSVGElement>(null);\n  \n  // Функция проверки ключевых слов\n  const isChairOrSeat = (productName?: string) => {\n    if (!productName) return false;\n    const lowerName = productName.toLowerCase();\n    return lowerName.includes('стул') || lowerName.includes('кресло');\n  };\n\n  // Генерация всех возможных ориентаций груза\n  const generateOrientations = (cargo: Cargo): Orientation[] => {\n    const orientations: Orientation[] = [];\n    const baseDimensions = [\n      [cargo.length, cargo.width, cargo.height],\n      [cargo.width, cargo.length, cargo.height],\n      [cargo.length, cargo.height, cargo.width],\n      [cargo.height, cargo.length, cargo.width],\n      [cargo.width, cargo.height, cargo.length],\n      [cargo.height, cargo.width, cargo.length]\n    ];\n\n    // Для стульев/кресел ограничиваем повороты (нельзя переворачивать)\n    const allowedDimensions = isChairOrSeat(cargo.productName) \n      ? baseDimensions.slice(0, 2) // Только первые 2 варианта (без поворота по высоте)\n      : baseDimensions;\n\n    allowedDimensions.forEach(([l, w, h]) => {\n      ROTATION_ANGLES.forEach(angle => {\n        // Вычисляем размеры после поворота\n        const rad = (angle * Math.PI) / 180;\n        const cos = Math.abs(Math.cos(rad));\n        const sin = Math.abs(Math.sin(rad));\n        \n        const rotatedLength = l * cos + w * sin;\n        const rotatedWidth = l * sin + w * cos;\n\n        orientations.push({\n          length: rotatedLength,\n          width: rotatedWidth,\n          height: h,\n          rotationAngle: angle,\n          flipped: h !== cargo.height\n        });\n      });\n    });\n\n    return orientations;\n  };\n\n  // Проверка пересечения двух прямоугольников с учетом поворота\n  const checkCollision = (\n    x1: number, y1: number, x2: number, y2: number,\n    length1: number, width1: number, length2: number, width2: number,\n    angle1: number, angle2: number\n  ): boolean => {\n    // Упрощенная проверка через ограничивающие прямоугольники\n    const rad1 = (angle1 * Math.PI) / 180;\n    const rad2 = (angle2 * Math.PI) / 180;\n    \n    const cos1 = Math.abs(Math.cos(rad1));\n    const sin1 = Math.abs(Math.sin(rad1));\n    const cos2 = Math.abs(Math.cos(rad2));\n    const sin2 = Math.abs(Math.sin(rad2));\n    \n    const bbox1 = {\n      minX: x1,\n      maxX: x1 + length1 * cos1 + width1 * sin1,\n      minY: y1,\n      maxY: y1 + length1 * sin1 + width1 * cos1\n    };\n    \n    const bbox2 = {\n      minX: x2,\n      maxX: x2 + length2 * cos2 + width2 * sin2,\n      minY: y2,\n      maxY: y2 + length2 * sin2 + width2 * cos2\n    };\n\n    return !(bbox1.maxX <= bbox2.minX || bbox2.maxX <= bbox1.minX ||\n             bbox1.maxY <= bbox2.minY || bbox2.maxY <= bbox1.minY);\n  };\n\n  // Проверка валидности позиции\n  const isPositionValid = (\n    x: number, y: number, z: number,\n    orientation: Orientation,\n    placements: CargoPlacement[],\n    cargo: Cargo\n  ): boolean => {\n    \n    // Проверяем границы кузова\n    const rad = (orientation.rotationAngle * Math.PI) / 180;\n    const cos = Math.abs(Math.cos(rad));\n    const sin = Math.abs(Math.sin(rad));\n    \n    const effectiveLength = orientation.length * cos + orientation.width * sin;\n    const effectiveWidth = orientation.length * sin + orientation.width * cos;\n    \n    if (x + effectiveLength > TRUCK_DIMENSIONS.length || \n        y + effectiveWidth > TRUCK_DIMENSIONS.width ||\n        z + orientation.height > TRUCK_DIMENSIONS.height) {\n      return false;\n    }\n\n    // Проверяем пересечения с уже размещенными грузами\n    for (const placement of placements) {\n      // Проверка по высоте\n      if (!(z >= placement.z + placement.orientation.height || \n            z + orientation.height <= placement.z)) {\n        \n        // Если высоты пересекаются, проверяем пересечение по площади\n        if (checkCollision(\n          x, y, placement.x, placement.y,\n          orientation.length, orientation.width,\n          placement.orientation.length, placement.orientation.width,\n          orientation.rotationAngle, placement.orientation.rotationAngle\n        )) {\n          return false;\n        }\n      }\n    }\n\n    // Проверяем правила размещения\n    if (z > 0) { // Груз не на полу\n      const supportingCargos = placements.filter(p => \n        z === p.z + p.orientation.height && // Стоит прямо на другом грузе\n        !checkCollision(\n          x, y, p.x, p.y,\n          orientation.length, orientation.width,\n          p.orientation.length, p.orientation.width,\n          orientation.rotationAngle, p.orientation.rotationAngle\n        ) === false // Есть пересечение по площади (поддержка)\n      );\n\n      if (supportingCargos.length === 0) {\n        return false; // Должен на чем-то стоять\n      }\n\n      // Правило по весу\n      for (const supporting of supportingCargos) {\n        if (cargo.weight > supporting.cargo.weight) {\n          return false;\n        }\n      }\n\n      // Правила для стульев/кресел\n      if (isChairOrSeat(cargo.productName)) {\n        const allSupportingAreChairs = supportingCargos.every(p => \n          isChairOrSeat(p.cargo.productName)\n        );\n        \n        if (!allSupportingAreChairs) {\n          return false;\n        }\n\n        // Максимум 2 стула друг на друге\n        let chairLevels = 1;\n        let currentZ = z;\n        \n        while (currentZ > 0) {\n          const chairsBelow = placements.filter(p =>\n            p.z + p.orientation.height === currentZ &&\n            isChairOrSeat(p.cargo.productName)\n          );\n          \n          if (chairsBelow.length > 0) {\n            chairLevels++;\n            currentZ = Math.min(...chairsBelow.map(p => p.z));\n          } else {\n            break;\n          }\n        }\n        \n        if (chairLevels > 2) {\n          return false;\n        }\n      } else {\n        // Обычные грузы нельзя ставить на стулья\n        const hasChairSupport = supportingCargos.some(p => \n          isChairOrSeat(p.cargo.productName)\n        );\n        \n        if (hasChairSupport) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // Расчет площади пола, занимаемой размещениями\n  const calculateFloorArea = (placements: CargoPlacement[], newPlacement?: CargoPlacement) => {\n    const allPlacements = newPlacement ? [...placements, newPlacement] : placements;\n    \n    if (allPlacements.length === 0) return 0;\n\n    let minX = Infinity, maxX = 0, minY = Infinity, maxY = 0;\n\n    allPlacements.forEach(p => {\n      const rad = (p.orientation.rotationAngle * Math.PI) / 180;\n      const cos = Math.abs(Math.cos(rad));\n      const sin = Math.abs(Math.sin(rad));\n      \n      const effectiveLength = p.orientation.length * cos + p.orientation.width * sin;\n      const effectiveWidth = p.orientation.length * sin + p.orientation.width * cos;\n      \n      minX = Math.min(minX, p.x);\n      maxX = Math.max(maxX, p.x + effectiveLength);\n      minY = Math.min(minY, p.y);\n      maxY = Math.max(maxY, p.y + effectiveWidth);\n    });\n\n    return (maxX - minX) * (maxY - minY);\n  };\n\n  // 3D матричные трансформации\n  const applyRotations = (vertices: number[][]) => {\n    const radX = (rotationX * Math.PI) / 180;\n    const radY = (rotationY * Math.PI) / 180;\n    const radZ = (rotationZ * Math.PI) / 180;\n\n    return vertices.map(([x, y, z]) => {\n      // Поворот по оси X\n      let newY = y * Math.cos(radX) - z * Math.sin(radX);\n      let newZ = y * Math.sin(radX) + z * Math.cos(radX);\n      y = newY;\n      z = newZ;\n\n      // Поворот по оси Y\n      let newX = x * Math.cos(radY) + z * Math.sin(radY);\n      newZ = -x * Math.sin(radY) + z * Math.cos(radY);\n      x = newX;\n      z = newZ;\n\n      // Поворот по оси Z\n      newX = x * Math.cos(radZ) - y * Math.sin(radZ);\n      newY = x * Math.sin(radZ) + y * Math.cos(radZ);\n      \n      return [newX, newY, newZ];\n    });\n  };\n\n  // Проекция 3D точек на 2D плоскость с учетом позиции и масштаба\n  const project3DTo2D = (vertices: number[][]) => {\n    const currentScale = (scale / 100) * 0.15; // Базовый масштаб\n    const svgWidth = 600;\n    const svgHeight = 400;\n    const offsetX = (positionX / 100) * svgWidth;\n    const offsetY = (positionY / 100) * svgHeight;\n    \n    return vertices.map(([x, y, z]) => {\n      // Простая ортогональная проекция с перспективой\n      const perspective = 1 + z * 0.0001;\n      const projX = (x * currentScale / perspective) + offsetX;\n      const projY = offsetY - (y * currentScale / perspective) - (z * currentScale * 0.7 / perspective);\n      \n      return { x: projX, y: projY };\n    });\n  };\n\n  // Основной алгоритм размещения\n  const calculateCargoPlacement = (): CargoPlacement[] => {\n    if (!cargos.length) return [];\n\n    // Фильтруем только заполненные грузы\n    const validCargos = cargos.filter(cargo => \n      cargo.length > 0 && cargo.width > 0 && cargo.height > 0 && cargo.weight > 0\n    );\n\n    if (!validCargos.length) return [];\n\n    // Сортировка: стулья первыми, потом по весу, потом по объему\n    const sortedCargos = [...validCargos].sort((a, b) => {\n      const aIsChair = isChairOrSeat(a.productName);\n      const bIsChair = isChairOrSeat(b.productName);\n      \n      if (aIsChair && !bIsChair) return -1;\n      if (!aIsChair && bIsChair) return 1;\n      \n      const weightDiff = b.weight - a.weight;\n      if (weightDiff !== 0) return weightDiff;\n      \n      const volumeA = a.length * a.width * a.height;\n      const volumeB = b.length * b.width * b.height;\n      return volumeB - volumeA;\n    });\n\n    const placements: CargoPlacement[] = [];\n\n    sortedCargos.forEach((cargo, index) => {\n      const color = CARGO_COLORS[index % CARGO_COLORS.length];\n      const orientations = generateOrientations(cargo);\n      \n      let bestPlacement: CargoPlacement | null = null;\n      let bestScore = Infinity;\n\n      // Генерируем возможные Z позиции\n      const possibleZ = [0];\n      placements.forEach(p => {\n        const topZ = p.z + p.orientation.height;\n        if (topZ <= TRUCK_DIMENSIONS.height - 100) { // Минимум 100мм сверху\n          possibleZ.push(topZ);\n        }\n      });\n      \n      const uniqueZ = possibleZ.filter((value, index, self) => self.indexOf(value) === index);\n      const sortedZ = uniqueZ.sort((a, b) => a - b);\n\n      // Перебираем все ориентации и позиции\n      for (const orientation of orientations) {\n        for (const z of sortedZ) {\n          if (z + orientation.height > TRUCK_DIMENSIONS.height) continue;\n\n          // Более частая сетка для точного размещения\n          const step = 25; // 25мм шаг\n          \n          for (let y = 0; y <= TRUCK_DIMENSIONS.width - 50; y += step) {\n            for (let x = 0; x <= TRUCK_DIMENSIONS.length - 50; x += step) {\n              \n              if (isPositionValid(x, y, z, orientation, placements, cargo)) {\n                const testPlacement: CargoPlacement = {\n                  cargo,\n                  x, y, z,\n                  orientation,\n                  color,\n                  projectedVertices: []\n                };\n\n                // Оценка: приоритет площади пола, потом высота, потом объем\n                const floorArea = calculateFloorArea(placements, testPlacement);\n                const heightPenalty = z * 0.001;\n                const volumePenalty = (floorArea * orientation.height) * 0.000001;\n                const score = floorArea + heightPenalty + volumePenalty;\n\n                if (score < bestScore) {\n                  bestScore = score;\n                  bestPlacement = testPlacement;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (bestPlacement) {\n        // Вычисляем проекционные вершины для 3D отображения\n        bestPlacement.projectedVertices = calculateProjectedVertices(bestPlacement);\n        placements.push(bestPlacement);\n      }\n    });\n\n    return placements;\n  };\n\n  // Вычисление проекционных вершин для 3D отображения грузов\n  const calculateProjectedVertices = (placement: CargoPlacement) => {\n    const { x, y, z, orientation } = placement;\n    const angle = orientation.rotationAngle * Math.PI / 180;\n    \n    // Основные вершины параллелепипеда\n    const vertices3D = [\n      [x, y, z],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z],\n      // Верхние вершины\n      [x, y, z + orientation.height],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z + orientation.height],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z + orientation.height],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z + orientation.height]\n    ];\n\n    // Применяем 3D повороты и проекцию\n    const rotatedVertices = applyRotations(vertices3D);\n    return project3DTo2D(rotatedVertices);\n  };\n\n  // Вычисление вершин кузова\n  const calculateTruckVertices = () => {\n    const vertices3D = [\n      // Нижние вершины кузова\n      [0, 0, 0],\n      [TRUCK_DIMENSIONS.length, 0, 0],\n      [TRUCK_DIMENSIONS.length, TRUCK_DIMENSIONS.width, 0],\n      [0, TRUCK_DIMENSIONS.width, 0],\n      // Верхние вершины кузова\n      [0, 0, TRUCK_DIMENSIONS.height],\n      [TRUCK_DIMENSIONS.length, 0, TRUCK_DIMENSIONS.height],\n      [TRUCK_DIMENSIONS.length, TRUCK_DIMENSIONS.width, TRUCK_DIMENSIONS.height],\n      [0, TRUCK_DIMENSIONS.width, TRUCK_DIMENSIONS.height]\n    ];\n\n    const rotatedVertices = applyRotations(vertices3D);\n    return project3DTo2D(rotatedVertices);\n  };\n\n  // Вычисление вершин кабины и шасси\n  const calculateCabinAndChassisVertices = () => {\n    const cabinLength = 2000; // 2 метра\n    const cabinHeight = 2500; // 2.5 метра  \n    const cabinWidth = TRUCK_DIMENSIONS.width;\n    const chassisHeight = 300; // Высота шасси\n    \n    // Кабина (впереди кузова)\n    const cabinVertices = [\n      // Нижние вершины кабины\n      [-cabinLength, 0, 0],\n      [0, 0, 0],\n      [0, cabinWidth, 0],\n      [-cabinLength, cabinWidth, 0],\n      // Верхние вершины кабины\n      [-cabinLength, 0, cabinHeight],\n      [0, 0, cabinHeight],\n      [0, cabinWidth, cabinHeight],\n      [-cabinLength, cabinWidth, cabinHeight]\n    ];\n\n    // Шасси (под кабиной и кузовом)\n    const chassisVertices = [\n      // Шасси под кабиной\n      [-cabinLength, cabinWidth * 0.2, -chassisHeight],\n      [0, cabinWidth * 0.2, -chassisHeight],\n      [0, cabinWidth * 0.8, -chassisHeight],\n      [-cabinLength, cabinWidth * 0.8, -chassisHeight],\n      // Шасси под кузовом\n      [0, cabinWidth * 0.2, -chassisHeight],\n      [TRUCK_DIMENSIONS.length, cabinWidth * 0.2, -chassisHeight],\n      [TRUCK_DIMENSIONS.length, cabinWidth * 0.8, -chassisHeight],\n      [0, cabinWidth * 0.8, -chassisHeight]\n    ];\n\n    // Колеса\n    const wheelRadius = 200;\n    const wheelVertices = [\n      // Передние колеса\n      [-cabinLength * 0.8, 0, -chassisHeight],\n      [-cabinLength * 0.8, cabinWidth, -chassisHeight],\n      // Задние колеса\n      [TRUCK_DIMENSIONS.length * 0.8, 0, -chassisHeight],\n      [TRUCK_DIMENSIONS.length * 0.8, cabinWidth, -chassisHeight]\n    ];\n\n    const rotatedCabin = applyRotations(cabinVertices);\n    const rotatedChassis = applyRotations(chassisVertices);\n    const rotatedWheels = applyRotations(wheelVertices);\n    \n    return {\n      cabin: project3DTo2D(rotatedCabin),\n      chassis: project3DTo2D(rotatedChassis),\n      wheels: project3DTo2D(rotatedWheels),\n      wheelRadius: wheelRadius * (scale / 100) * 0.15\n    };\n  };\n\n  // Обработчики джойстика\n  const handleJoystickStart = (event: React.MouseEvent<SVGSVGElement>) => {\n    setIsDragging(true);\n    const rect = joystickRef.current?.getBoundingClientRect();\n    if (rect) {\n      setDragStart({\n        x: event.clientX - rect.left,\n        y: event.clientY - rect.top\n      });\n    }\n  };\n\n  const handleJoystickMove = (event: React.MouseEvent<SVGSVGElement>) => {\n    if (!isDragging || !joystickRef.current) return;\n    \n    const rect = joystickRef.current.getBoundingClientRect();\n    const centerX = rect.width / 2;\n    const centerY = rect.height / 2;\n    const currentX = event.clientX - rect.left;\n    const currentY = event.clientY - rect.top;\n    \n    const deltaX = (currentX - centerX) / centerX; // -1 до 1\n    const deltaY = (currentY - centerY) / centerY; // -1 до 1\n    \n    // Плавное обновление углов поворота\n    setRotationY(prev => Math.max(-90, Math.min(90, prev + deltaX * 2)));\n    setRotationX(prev => Math.max(-90, Math.min(90, prev + deltaY * 2)));\n  };\n\n  const handleJoystickEnd = () => {\n    setIsDragging(false);\n  };\n\n  // Эффект для обработки движения мыши вне джойстика\n  useEffect(() => {\n    const handleMouseMove = (event: MouseEvent) => {\n      if (isDragging && joystickRef.current) {\n        const rect = joystickRef.current.getBoundingClientRect();\n        const centerX = rect.width / 2;\n        const centerY = rect.height / 2;\n        const currentX = event.clientX - rect.left;\n        const currentY = event.clientY - rect.top;\n        \n        const deltaX = (currentX - centerX) / centerX;\n        const deltaY = (currentY - centerY) / centerY;\n        \n        setRotationY(prev => Math.max(-90, Math.min(90, prev + deltaX * 2)));\n        setRotationX(prev => Math.max(-90, Math.min(90, prev + deltaY * 2)));\n      }\n    };\n\n    const handleMouseUp = () => {\n      setIsDragging(false);\n    };\n\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n    }\n\n    return () => {\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n    };\n  }, [isDragging]);\n\n  // Функция для получения первых двух слов из названия товара\n  const getProductShortName = (productName?: string) => {\n    if (!productName) return '';\n    const words = productName.trim().split(/\\s+/);\n    return words.slice(0, 2).join(' ');\n  };\n\n  const placements = calculateCargoPlacement();\n\n  // Расчет статистики\n  const calculateStats = () => {\n    if (!placements.length) return null;\n\n    const floorArea = calculateFloorArea(placements);\n    \n    let maxX = 0, maxY = 0, maxZ = 0;\n    placements.forEach(p => {\n      const rad = (p.orientation.rotationAngle * Math.PI) / 180;\n      const cos = Math.abs(Math.cos(rad));\n      const sin = Math.abs(Math.sin(rad));\n      \n      const effectiveLength = p.orientation.length * cos + p.orientation.width * sin;\n      const effectiveWidth = p.orientation.length * sin + p.orientation.width * cos;\n      \n      maxX = Math.max(maxX, p.x + effectiveLength);\n      maxY = Math.max(maxY, p.y + effectiveWidth);\n      maxZ = Math.max(maxZ, p.z + p.orientation.height);\n    });\n\n    const occupiedVolume = (maxX * maxY * maxZ) / 1000000000; // в м³\n    const floorUtilization = (floorArea / ((TRUCK_DIMENSIONS.length * TRUCK_DIMENSIONS.width))) * 100;\n\n    return {\n      occupiedFloorArea: (floorArea / 1000000).toFixed(2), // в м²\n      occupiedVolume: occupiedVolume.toFixed(3),\n      floorUtilization: floorUtilization.toFixed(1),\n      dimensions: {\n        length: (maxX / 1000).toFixed(2),\n        width: (maxY / 1000).toFixed(2),\n        height: (maxZ / 1000).toFixed(2)\n      }\n    };\n  };\n\n  const stats = calculateStats();\n  const truckVertices = calculateTruckVertices();\n  const truckComponents = calculateCabinAndChassisVertices();\n\n  if (!isVisible) return null;\n\n  return (\n    <Card className=\"bg-gray-800 border-gray-700\">\n      <CardHeader className=\"pb-3\">\n        <CardTitle className=\"text-white flex items-center gap-2 text-lg\">\n          <Truck className=\"h-4 w-4\" />\n          Интерактивная 3D визуализация грузовика с размещением груза\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        {/* Панель управления 3D моделью */}\n        <div className=\"bg-gray-800 p-4 rounded-lg mb-4 space-y-4\">\n          <div className=\"flex items-center justify-between\">\n            <h4 className=\"text-white font-medium flex items-center gap-2\">\n              <Rotate3d className=\"h-4 w-4\" />\n              Управление 3D моделью\n            </h4>\n            <Button\n              variant=\"outline\"\n              size=\"sm\"\n              onClick={() => {\n                setRotationX(15);\n                setRotationY(25);\n                setRotationZ(0);\n                setPositionX(50);\n                setPositionY(50);\n                setScale(50);\n              }}\n              className=\"text-white border-gray-600 hover:bg-gray-700\"\n            >\n              Сброс\n            </Button>\n          </div>\n          \n          <div className=\"grid grid-cols-1 lg:grid-cols-3 gap-6\">\n            {/* Джойстик для поворотов */}\n            <div className=\"space-y-2\">\n              <label className=\"text-sm text-gray-300 flex items-center gap-2\">\n                <Rotate3d className=\"h-3 w-3\" />\n                Поворот (X: {rotationX.toFixed(0)}°, Y: {rotationY.toFixed(0)}°)\n              </label>\n              <div className=\"flex justify-center\">\n                <svg\n                  ref={joystickRef}\n                  width=\"80\"\n                  height=\"80\"\n                  className=\"border border-gray-600 rounded-full bg-gray-900 cursor-move\"\n                  onMouseDown={handleJoystickStart}\n                  onMouseMove={handleJoystickMove}\n                  onMouseUp={handleJoystickEnd}\n                >\n                  {/* Внешний круг */}\n                  <circle cx=\"40\" cy=\"40\" r=\"35\" fill=\"none\" stroke=\"#4B5563\" strokeWidth=\"2\" />\n                  \n                  {/* Центральные оси */}\n                  <line x1=\"40\" y1=\"10\" x2=\"40\" y2=\"70\" stroke=\"#6B7280\" strokeWidth=\"1\" strokeDashArray=\"2,2\" />\n                  <line x1=\"10\" y1=\"40\" x2=\"70\" y2=\"40\" stroke=\"#6B7280\" strokeWidth=\"1\" strokeDashArray=\"2,2\" />\n                  \n                  {/* Джойстик */}\n                  <circle \n                    cx={40 + (rotationY / 90) * 25} \n                    cy={40 + (rotationX / 90) * 25} \n                    r=\"8\" \n                    fill={isDragging ? '#3B82F6' : '#6B7280'} \n                    stroke=\"white\" \n                    strokeWidth=\"2\"\n                    className=\"transition-colors\"\n                  />\n                  \n                  {/* Указатели осей */}\n                  <text x=\"40\" y=\"8\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"8\">-X</text>\n                  <text x=\"40\" y=\"76\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"8\">+X</text>\n                  <text x=\"8\" y=\"44\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"8\">-Y</text>\n                  <text x=\"72\" y=\"44\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"8\">+Y</text>\n                </svg>\n              </div>\n            </div>\n            \n            {/* Слайдеры позиции */}\n            <div className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <label className=\"text-sm text-gray-300 flex items-center gap-2\">\n                  <Move className=\"h-3 w-3\" />\n                  Позиция X: {positionX.toFixed(0)}%\n                </label>\n                <Slider\n                  value={[positionX]}\n                  onValueChange={(value) => setPositionX(value[0])}\n                  max={100}\n                  min={0}\n                  step={1}\n                  className=\"w-full\"\n                />\n              </div>\n              \n              <div className=\"space-y-2\">\n                <label className=\"text-sm text-gray-300\">\n                  Позиция Y: {positionY.toFixed(0)}%\n                </label>\n                <Slider\n                  value={[positionY]}\n                  onValueChange={(value) => setPositionY(value[0])}\n                  max={100}\n                  min={0}\n                  step={1}\n                  className=\"w-full\"\n                />\n              </div>\n            </div>\n            \n            {/* Слайдеры масштаба и Z-поворота */}\n            <div className=\"space-y-4\">\n              <div className=\"space-y-2\">\n                <label className=\"text-sm text-gray-300\">\n                  Масштаб: {scale.toFixed(0)}%\n                </label>\n                <Slider\n                  value={[scale]}\n                  onValueChange={(value) => setScale(value[0])}\n                  max={100}\n                  min={10}\n                  step={1}\n                  className=\"w-full\"\n                />\n              </div>\n              \n              <div className=\"space-y-2\">\n                <label className=\"text-sm text-gray-300\">\n                  Поворот Z: {rotationZ.toFixed(0)}°\n                </label>\n                <Slider\n                  value={[rotationZ]}\n                  onValueChange={(value) => setRotationZ(value[0])}\n                  max={180}\n                  min={-180}\n                  step={5}\n                  className=\"w-full\"\n                />\n              </div>\n            </div>\n          </div>\n        </div>\n\n        {/* 3D SVG визуализация кузова */}\n        <div className=\"bg-gray-900 p-4 rounded-lg mb-4\">\n          <svg \n            viewBox=\"0 0 600 400\" \n            className=\"w-full h-96 border border-gray-600 bg-gray-950\"\n            style={{ maxHeight: '480px' }}\n          >\n            {/* Размеры кузова */}\n            <text x=\"300\" y=\"20\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"12\" fontWeight=\"bold\">\n              Грузовик с кузовом 4200×2025×2025 мм\n            </text>\n            \n            {/* Кабина грузовика */}\n            <g stroke=\"#10B981\" strokeWidth=\"2\" fill=\"#065F46\" fillOpacity=\"0.3\">\n              {/* Передняя стенка кабины */}\n              <polygon \n                points={`${truckComponents.cabin[0].x},${truckComponents.cabin[0].y} ${truckComponents.cabin[1].x},${truckComponents.cabin[1].y} ${truckComponents.cabin[5].x},${truckComponents.cabin[5].y} ${truckComponents.cabin[4].x},${truckComponents.cabin[4].y}`}\n              />\n              \n              {/* Правая боковая стенка кабины */}\n              <polygon \n                points={`${truckComponents.cabin[1].x},${truckComponents.cabin[1].y} ${truckComponents.cabin[2].x},${truckComponents.cabin[2].y} ${truckComponents.cabin[6].x},${truckComponents.cabin[6].y} ${truckComponents.cabin[5].x},${truckComponents.cabin[5].y}`}\n                fillOpacity=\"0.4\"\n              />\n              \n              {/* Верх кабины */}\n              <polygon \n                points={`${truckComponents.cabin[4].x},${truckComponents.cabin[4].y} ${truckComponents.cabin[5].x},${truckComponents.cabin[5].y} ${truckComponents.cabin[6].x},${truckComponents.cabin[6].y} ${truckComponents.cabin[7].x},${truckComponents.cabin[7].y}`}\n                fillOpacity=\"0.5\"\n              />\n              \n              {/* Левая стенка кабины */}\n              <polygon \n                points={`${truckComponents.cabin[3].x},${truckComponents.cabin[3].y} ${truckComponents.cabin[0].x},${truckComponents.cabin[0].y} ${truckComponents.cabin[4].x},${truckComponents.cabin[4].y} ${truckComponents.cabin[7].x},${truckComponents.cabin[7].y}`}\n                fillOpacity=\"0.2\"\n              />\n            </g>\n            \n            {/* Шасси */}\n            <g stroke=\"#374151\" strokeWidth=\"3\" fill=\"#1F2937\">\n              {/* Шасси под кабиной */}\n              <polygon \n                points={`${truckComponents.chassis[0].x},${truckComponents.chassis[0].y} ${truckComponents.chassis[1].x},${truckComponents.chassis[1].y} ${truckComponents.chassis[2].x},${truckComponents.chassis[2].y} ${truckComponents.chassis[3].x},${truckComponents.chassis[3].y}`}\n              />\n              \n              {/* Шасси под кузовом */}\n              <polygon \n                points={`${truckComponents.chassis[4].x},${truckComponents.chassis[4].y} ${truckComponents.chassis[5].x},${truckComponents.chassis[5].y} ${truckComponents.chassis[6].x},${truckComponents.chassis[6].y} ${truckComponents.chassis[7].x},${truckComponents.chassis[7].y}`}\n              />\n            </g>\n            \n            {/* Колеса */}\n            <g fill=\"#1F2937\" stroke=\"#374151\" strokeWidth=\"2\">\n              {truckComponents.wheels.map((wheel, index) => (\n                <circle \n                  key={`wheel-${index}`}\n                  cx={wheel.x} \n                  cy={wheel.y} \n                  r={Math.max(truckComponents.wheelRadius, 3)}\n                />\n              ))}\n            </g>\n            \n            {/* Контур кузова в изометрии */}\n            <g stroke=\"#EF4444\" strokeWidth=\"2\" fill=\"none\">\n              {/* Пол кузова */}\n              <polygon \n                points={`${truckVertices[0].x},${truckVertices[0].y} ${truckVertices[1].x},${truckVertices[1].y} ${truckVertices[2].x},${truckVertices[2].y} ${truckVertices[3].x},${truckVertices[3].y}`}\n                fill=\"#7F1D1D\" \n                fillOpacity=\"0.3\" \n              />\n              \n              {/* Задняя стенка */}\n              <polygon \n                points={`${truckVertices[0].x},${truckVertices[0].y} ${truckVertices[1].x},${truckVertices[1].y} ${truckVertices[5].x},${truckVertices[5].y} ${truckVertices[4].x},${truckVertices[4].y}`}\n                strokeDasharray=\"3,3\" \n              />\n              \n              {/* Правая боковая стенка */}\n              <polygon \n                points={`${truckVertices[1].x},${truckVertices[1].y} ${truckVertices[2].x},${truckVertices[2].y} ${truckVertices[6].x},${truckVertices[6].y} ${truckVertices[5].x},${truckVertices[5].y}`}\n                strokeDasharray=\"3,3\" \n              />\n              \n              {/* Передняя стенка */}\n              <polygon \n                points={`${truckVertices[2].x},${truckVertices[2].y} ${truckVertices[3].x},${truckVertices[3].y} ${truckVertices[7].x},${truckVertices[7].y} ${truckVertices[6].x},${truckVertices[6].y}`}\n                strokeDasharray=\"3,3\" \n              />\n              \n              {/* Левая боковая стенка */}\n              <polygon \n                points={`${truckVertices[3].x},${truckVertices[3].y} ${truckVertices[0].x},${truckVertices[0].y} ${truckVertices[4].x},${truckVertices[4].y} ${truckVertices[7].x},${truckVertices[7].y}`}\n                strokeDasharray=\"3,3\" \n              />\n              \n              {/* Верх кузова */}\n              <polygon \n                points={`${truckVertices[4].x},${truckVertices[4].y} ${truckVertices[5].x},${truckVertices[5].y} ${truckVertices[6].x},${truckVertices[6].y} ${truckVertices[7].x},${truckVertices[7].y}`}\n                strokeDasharray=\"3,3\" \n              />\n            </g>\n            \n            {/* Отображение размещенных грузов */}\n            {placements.map((placement, index) => {\n              const vertices = placement.projectedVertices;\n              if (vertices.length < 8) return null;\n\n              return (\n                <g key={`cargo-3d-${index}`}>\n                  {/* Нижняя грань */}\n                  <polygon\n                    points={`${vertices[0].x},${vertices[0].y} ${vertices[1].x},${vertices[1].y} ${vertices[2].x},${vertices[2].y} ${vertices[3].x},${vertices[3].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.6\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n                  \n                  {/* Верхняя грань */}\n                  <polygon\n                    points={`${vertices[4].x},${vertices[4].y} ${vertices[5].x},${vertices[5].y} ${vertices[6].x},${vertices[6].y} ${vertices[7].x},${vertices[7].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.8\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n                  \n                  {/* Боковые грани */}\n                  <polygon\n                    points={`${vertices[1].x},${vertices[1].y} ${vertices[2].x},${vertices[2].y} ${vertices[6].x},${vertices[6].y} ${vertices[5].x},${vertices[5].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.7\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n                  \n                  <polygon\n                    points={`${vertices[2].x},${vertices[2].y} ${vertices[3].x},${vertices[3].y} ${vertices[7].x},${vertices[7].y} ${vertices[6].x},${vertices[6].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.5\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n\n                  {/* Номер груза */}\n                  <text\n                    x={(vertices[4].x + vertices[6].x) / 2}\n                    y={(vertices[4].y + vertices[6].y) / 2}\n                    textAnchor=\"middle\"\n                    dominantBaseline=\"middle\"\n                    fill=\"white\"\n                    fontSize=\"8\"\n                    fontWeight=\"bold\"\n                  >\n                    {index + 1}\n                  </text>\n                </g>\n              );\n            })}\n          </svg>\n        </div>\n\n        {/* Статистика размещения */}\n        {stats && (\n          <div className=\"grid grid-cols-2 gap-4 text-sm\">\n            <div className=\"space-y-2\">\n              <h4 className=\"font-medium text-white\">Занятые размеры:</h4>\n              <div className=\"text-gray-300 space-y-1\">\n                <div>Длина: {stats.dimensions.length} м</div>\n                <div>Ширина: {stats.dimensions.width} м</div>\n                <div>Высота: {stats.dimensions.height} м</div>\n              </div>\n            </div>\n            <div className=\"space-y-2\">\n              <h4 className=\"font-medium text-white\">Использование:</h4>\n              <div className=\"text-gray-300 space-y-1\">\n                <div>Площадь пола: {stats.occupiedFloorArea} м²</div>\n                <div>Объем: {stats.occupiedVolume} м³</div>\n                <div>Загрузка пола: {stats.floorUtilization}%</div>\n              </div>\n            </div>\n          </div>\n        )}\n\n        {/* Легенда грузов */}\n        {placements.length > 0 && (\n          <div className=\"mt-4\">\n            <h4 className=\"font-medium text-white mb-2\">Размещенные грузы:</h4>\n            <div className=\"grid grid-cols-1 gap-2 text-xs max-h-32 overflow-y-auto\">\n              {placements.map((placement, index) => (\n                <div key={`legend-${index}`} className=\"flex items-center gap-2\">\n                  <div \n                    className=\"w-3 h-3 rounded\"\n                    style={{ backgroundColor: placement.color }}\n                  />\n                  <span className=\"text-gray-300\">\n                    Груз {index + 1}{getProductShortName(placement.cargo.productName) && (\n                      <span className=\"text-blue-300\"> \"{getProductShortName(placement.cargo.productName)}\"</span>\n                    )}: {Math.round(placement.orientation.length)}×{Math.round(placement.orientation.width)}×{Math.round(placement.orientation.height)} мм\n                    {placement.orientation.rotationAngle !== 0 && (\n                      <span className=\"text-blue-300\"> (повернут {placement.orientation.rotationAngle}°)</span>\n                    )}\n                  </span>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/components/TruckVisualization.tsx",
      "exists": true
    },
    "title": "components/TruckVisualization.tsx",
    "time": {
      "start": 1759136824675,
      "end": 1759136824679
    }
  }
}