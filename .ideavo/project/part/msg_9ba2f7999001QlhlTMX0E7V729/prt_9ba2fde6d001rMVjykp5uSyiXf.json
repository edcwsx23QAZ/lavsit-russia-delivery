{
  "id": "prt_9ba2fde6d001rMVjykp5uSyiXf",
  "messageID": "msg_9ba2f7999001QlhlTMX0E7V729",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_011zg4rNXqhBnkbxYeSfBGbi",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/lib/cookie-storage.ts",
      "content": "'use client';\n\n// Cookie-based storage for form data - survives Clear-Site-Data headers\nconst FORM_DATA_COOKIE = 'lavsit_form_data';\nconst FORM_VERSION_COOKIE = 'lavsit_form_version';\nconst MAX_COOKIE_SIZE = 4000; // Safe limit for cookie size\nconst COOKIE_EXPIRY_DAYS = 30;\n\ninterface CookieOptions {\n  expires?: Date;\n  path?: string;\n  domain?: string;\n  secure?: boolean;\n  sameSite?: 'Strict' | 'Lax' | 'None';\n  httpOnly?: boolean;\n}\n\nclass CookieStorage {\n  private isClient(): boolean {\n    return typeof window !== 'undefined' && typeof document !== 'undefined';\n  }\n\n  private setCookie(name: string, value: string, options: CookieOptions = {}): boolean {\n    try {\n      if (!this.isClient()) {\n        console.warn('[COOKIE] Not available in SSR');\n        return false;\n      }\n\n      // Check cookie size limit\n      if (value.length > MAX_COOKIE_SIZE) {\n        console.warn(`[COOKIE] Value too large for ${name}: ${value.length} chars`);\n        return false;\n      }\n\n      const expires = options.expires || new Date(Date.now() + COOKIE_EXPIRY_DAYS * 24 * 60 * 60 * 1000);\n      const path = options.path || '/';\n      const secure = options.secure !== undefined ? options.secure : window.location.protocol === 'https:';\n      const sameSite = options.sameSite || 'Lax';\n\n      let cookieString = `${encodeURIComponent(name)}=${encodeURIComponent(value)}`;\n      cookieString += `; expires=${expires.toUTCString()}`;\n      cookieString += `; path=${path}`;\n      \n      if (secure) {\n        cookieString += '; Secure';\n      }\n      \n      cookieString += `; SameSite=${sameSite}`;\n\n      document.cookie = cookieString;\n      console.log(`[COOKIE] Set ${name} (${value.length} chars)`);\n      return true;\n    } catch (error) {\n      console.error(`[COOKIE] Failed to set ${name}:`, error);\n      return false;\n    }\n  }\n\n  private getCookie(name: string): string | null {\n    try {\n      if (!this.isClient()) {\n        return null;\n      }\n\n      const nameEQ = encodeURIComponent(name) + '=';\n      const cookies = document.cookie.split(';');\n      \n      for (let cookie of cookies) {\n        cookie = cookie.trim();\n        if (cookie.indexOf(nameEQ) === 0) {\n          const value = decodeURIComponent(cookie.substring(nameEQ.length));\n          console.log(`[COOKIE] Retrieved ${name} (${value.length} chars)`);\n          return value;\n        }\n      }\n      \n      console.log(`[COOKIE] No cookie found for ${name}`);\n      return null;\n    } catch (error) {\n      console.error(`[COOKIE] Failed to get ${name}:`, error);\n      return null;\n    }\n  }\n\n  private removeCookie(name: string): boolean {\n    try {\n      if (!this.isClient()) {\n        return false;\n      }\n\n      document.cookie = `${encodeURIComponent(name)}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/`;\n      console.log(`[COOKIE] Removed ${name}`);\n      return true;\n    } catch (error) {\n      console.error(`[COOKIE] Failed to remove ${name}:`, error);\n      return false;\n    }\n  }\n\n  // Compress JSON string for cookie storage\n  private compressData(data: string): string {\n    try {\n      // Simple compression: remove unnecessary whitespace and use shorter field names\n      const parsed = JSON.parse(data);\n      \n      // Create a compressed version with shorter keys\n      const compressed = {\n        v: parsed.version,\n        t: parsed.timestamp,\n        c: parsed.cargos,\n        fc: parsed.fromCity,\n        tc: parsed.toCity,\n        fa: parsed.fromAddress,\n        ta: parsed.toAddress,\n        dv: parsed.declaredValue,\n        np: parsed.needPackaging,\n        nl: parsed.needLoading,\n        nc: parsed.needCarry,\n        f: parsed.floor,\n        hfl: parsed.hasFreightLift,\n        ni: parsed.needInsurance,\n        ft: parsed.fromTerminal,\n        tt: parsed.toTerminal,\n        fad: parsed.fromAddressDelivery,\n        tad: parsed.toAddressDelivery,\n        flw: parsed.fromLavsiteWarehouse,\n        sp: parsed.selectedProducts,\n        ec: parsed.enabledCompanies\n      };\n\n      return JSON.stringify(compressed);\n    } catch (error) {\n      console.warn('[COOKIE] Failed to compress data, using original:', error);\n      return data;\n    }\n  }\n\n  // Decompress JSON string from cookie storage\n  private decompressData(data: string): string {\n    try {\n      const compressed = JSON.parse(data);\n      \n      // Check if it's already in full format\n      if (compressed.version) {\n        return data;\n      }\n      \n      // Restore full field names\n      const decompressed = {\n        version: compressed.v,\n        timestamp: compressed.t,\n        cargos: compressed.c,\n        fromCity: compressed.fc,\n        toCity: compressed.tc,\n        fromAddress: compressed.fa,\n        toAddress: compressed.ta,\n        declaredValue: compressed.dv,\n        needPackaging: compressed.np,\n        needLoading: compressed.nl,\n        needCarry: compressed.nc,\n        floor: compressed.f,\n        hasFreightLift: compressed.hfl,\n        needInsurance: compressed.ni,\n        fromTerminal: compressed.ft,\n        toTerminal: compressed.tt,\n        fromAddressDelivery: compressed.fad,\n        toAddressDelivery: compressed.tad,\n        fromLavsiteWarehouse: compressed.flw,\n        selectedProducts: compressed.sp,\n        enabledCompanies: compressed.ec\n      };\n\n      return JSON.stringify(decompressed);\n    } catch (error) {\n      console.warn('[COOKIE] Failed to decompress data, using original:', error);\n      return data;\n    }\n  }\n\n  // Split large data into multiple cookies if needed\n  private setLargeData(baseName: string, data: string): boolean {\n    try {\n      const compressed = this.compressData(data);\n      \n      if (compressed.length <= MAX_COOKIE_SIZE) {\n        // Single cookie is enough\n        this.removeCookie(`${baseName}_parts`);\n        this.removeCookie(`${baseName}_1`);\n        this.removeCookie(`${baseName}_2`);\n        this.removeCookie(`${baseName}_3`);\n        return this.setCookie(baseName, compressed);\n      }\n\n      // Split into multiple parts\n      const parts: string[] = [];\n      for (let i = 0; i < compressed.length; i += MAX_COOKIE_SIZE) {\n        parts.push(compressed.substring(i, i + MAX_COOKIE_SIZE));\n      }\n\n      if (parts.length > 3) {\n        console.error(`[COOKIE] Data too large even when split: ${parts.length} parts`);\n        return false;\n      }\n\n      // Set number of parts\n      this.setCookie(`${baseName}_parts`, parts.length.toString());\n      \n      // Set each part\n      let success = true;\n      for (let i = 0; i < parts.length; i++) {\n        success = success && this.setCookie(`${baseName}_${i + 1}`, parts[i]);\n      }\n\n      // Clear main cookie\n      this.removeCookie(baseName);\n      \n      console.log(`[COOKIE] Split data into ${parts.length} parts`);\n      return success;\n    } catch (error) {\n      console.error('[COOKIE] Failed to set large data:', error);\n      return false;\n    }\n  }\n\n  // Retrieve large data from multiple cookies\n  private getLargeData(baseName: string): string | null {\n    try {\n      // Try single cookie first\n      const singleData = this.getCookie(baseName);\n      if (singleData) {\n        return this.decompressData(singleData);\n      }\n\n      // Try multi-part cookies\n      const partsStr = this.getCookie(`${baseName}_parts`);\n      if (!partsStr) {\n        return null;\n      }\n\n      const numParts = parseInt(partsStr);\n      if (isNaN(numParts) || numParts <= 0) {\n        return null;\n      }\n\n      let combined = '';\n      for (let i = 1; i <= numParts; i++) {\n        const part = this.getCookie(`${baseName}_${i}`);\n        if (!part) {\n          console.error(`[COOKIE] Missing part ${i} of ${numParts}`);\n          return null;\n        }\n        combined += part;\n      }\n\n      console.log(`[COOKIE] Reconstructed data from ${numParts} parts`);\n      return this.decompressData(combined);\n    } catch (error) {\n      console.error('[COOKIE] Failed to get large data:', error);\n      return null;\n    }\n  }\n\n  // Remove all cookies related to large data\n  private removeLargeData(baseName: string): boolean {\n    let success = true;\n    \n    // Remove main cookie\n    success = success && this.removeCookie(baseName);\n    \n    // Remove parts info\n    const partsStr = this.getCookie(`${baseName}_parts`);\n    if (partsStr) {\n      const numParts = parseInt(partsStr);\n      if (!isNaN(numParts)) {\n        for (let i = 1; i <= numParts; i++) {\n          success = success && this.removeCookie(`${baseName}_${i}`);\n        }\n      }\n      success = success && this.removeCookie(`${baseName}_parts`);\n    }\n\n    return success;\n  }\n\n  // Public API\n  saveFormData(formData: string): boolean {\n    return this.setLargeData(FORM_DATA_COOKIE, formData);\n  }\n\n  loadFormData(): string | null {\n    return this.getLargeData(FORM_DATA_COOKIE);\n  }\n\n  saveFormVersion(version: string): boolean {\n    return this.setCookie(FORM_VERSION_COOKIE, version);\n  }\n\n  loadFormVersion(): string | null {\n    return this.getCookie(FORM_VERSION_COOKIE);\n  }\n\n  clearFormData(): boolean {\n    const success1 = this.removeLargeData(FORM_DATA_COOKIE);\n    const success2 = this.removeCookie(FORM_VERSION_COOKIE);\n    return success1 && success2;\n  }\n\n  // Get available cookie space\n  getAvailableSpace(): number {\n    if (!this.isClient()) return 0;\n    \n    const currentCookies = document.cookie;\n    const remainingSpace = MAX_COOKIE_SIZE - currentCookies.length;\n    return Math.max(0, remainingSpace);\n  }\n\n  // Test if cookies are working\n  testCookies(): boolean {\n    const testKey = 'test_cookie';\n    const testValue = 'test_value';\n    \n    if (!this.setCookie(testKey, testValue)) {\n      return false;\n    }\n    \n    const retrieved = this.getCookie(testKey);\n    this.removeCookie(testKey);\n    \n    return retrieved === testValue;\n  }\n}\n\n// Singleton instance\nconst cookieStorage = new CookieStorage();\n\n// Public API functions\nexport const saveFormDataToCookies = (formData: string): boolean => {\n  return cookieStorage.saveFormData(formData);\n};\n\nexport const loadFormDataFromCookies = (): string | null => {\n  return cookieStorage.loadFormData();\n};\n\nexport const saveFormVersionToCookies = (version: string): boolean => {\n  return cookieStorage.saveFormVersion(version);\n};\n\nexport const loadFormVersionFromCookies = (): string | null => {\n  return cookieStorage.loadFormVersion();\n};\n\nexport const clearFormDataFromCookies = (): boolean => {\n  return cookieStorage.clearFormData();\n};\n\nexport const isCookieStorageAvailable = (): boolean => {\n  return cookieStorage.testCookies();\n};\n\nexport const getCookieAvailableSpace = (): number => {\n  return cookieStorage.getAvailableSpace();\n};\n\nconsole.log('[COOKIE] Storage module initialized');"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/lib/cookie-storage.ts",
      "exists": false
    },
    "title": "lib/cookie-storage.ts",
    "time": {
      "start": 1759765364212,
      "end": 1759765364213
    }
  }
}