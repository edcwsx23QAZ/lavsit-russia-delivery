{
  "id": "prt_b22bbb4b9001WPeNVSYLIaWPtW",
  "sessionID": "ses_4ec400949ffekDUyPGFumLInaA",
  "messageID": "msg_b22bbacfe00255xujliclsFrCM",
  "type": "tool",
  "callID": "call_92667493",
  "tool": "read",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "lib/error-handling.ts"
    },
    "output": "<file>\n00001| import { apiRequestWithTimeout } from './api-utils';\n00002| \n00003| // Error types for better categorization\n00004| export enum ErrorType {\n00005|   NETWORK = 'NETWORK',\n00006|   API = 'API',\n00007|   VALIDATION = 'VALIDATION',\n00008|   TIMEOUT = 'TIMEOUT',\n00009|   RATE_LIMIT = 'RATE_LIMIT',\n00010|   SERVER = 'SERVER',\n00011|   UNKNOWN = 'UNKNOWN'\n00012| }\n00013| \n00014| export interface ErrorContext {\n00015|   operation: string;\n00016|   company?: string;\n00017|   requestId?: string;\n00018|   userId?: string;\n00019|   timestamp: string;\n00020|   retryCount?: number;\n00021|   userAgent?: string;\n00022|   url?: string;\n00023| }\n00024| \n00025| export interface RetryConfig {\n00026|   maxRetries: number;\n00027|   baseDelay: number;\n00028|   maxDelay: number;\n00029|   backoffFactor: number;\n00030|   retryableErrors: ErrorType[];\n00031| }\n00032| \n00033| export interface ErrorResult {\n00034|   success: false;\n00035|   error: {\n00036|     type: ErrorType;\n00037|     message: string;\n00038|     userMessage: string;\n00039|     technicalDetails?: any;\n00040|     context: ErrorContext;\n00041|     retryable: boolean;\n00042|     suggestedAction?: string;\n00043|   };\n00044|   fallbackData?: any;\n00045| }\n00046| \n00047| // Default retry configuration\n00048| const DEFAULT_RETRY_CONFIG: RetryConfig = {\n00049|   maxRetries: 3,\n00050|   baseDelay: 1000, // 1 second\n00051|   maxDelay: 30000, // 30 seconds\n00052|   backoffFactor: 2,\n00053|   retryableErrors: [ErrorType.NETWORK, ErrorType.TIMEOUT, ErrorType.SERVER, ErrorType.RATE_LIMIT]\n00054| };\n00055| \n00056| // User-friendly error messages\n00057| const USER_MESSAGES = {\n00058|   [ErrorType.NETWORK]: 'Проблемы с подключением к интернету. Проверьте соединение и попробуйте снова.',\n00059|   [ErrorType.API]: 'Временные проблемы с сервисом транспортной компании. Попробуйте позже.',\n00060|   [ErrorType.VALIDATION]: 'Проверьте правильность введенных данных.',\n00061|   [ErrorType.TIMEOUT]: 'Сервис отвечает слишком долго. Попробуйте еще раз.',\n00062|   [ErrorType.RATE_LIMIT]: 'Слишком много запросов. Подождите немного и попробуйте снова.',\n00063|   [ErrorType.SERVER]: 'Временные технические проблемы. Попробуйте позже.',\n00064|   [ErrorType.UNKNOWN]: 'Произошла неожиданная ошибка. Попробуйте еще раз.'\n00065| };\n00066| \n00067| // Suggested actions for different error types\n00068| const SUGGESTED_ACTIONS = {\n00069|   [ErrorType.NETWORK]: 'Проверьте интернет-соединение',\n00070|   [ErrorType.API]: 'Попробуйте выбрать другую транспортную компанию',\n00071|   [ErrorType.VALIDATION]: 'Проверьте корректность адресов и параметров груза',\n00072|   [ErrorType.TIMEOUT]: 'Попробуйте упростить запрос или выбрать меньшее количество грузов',\n00073|   [ErrorType.RATE_LIMIT]: 'Подождите 1-2 минуты перед следующим запросом',\n00074|   [ErrorType.SERVER]: 'Свяжитесь с поддержкой если проблема persists',\n00075|   [ErrorType.UNKNOWN]: 'Свяжитесь с поддержкой'\n00076| };\n00077| \n00078| // Cache for storing successful results to provide fallbacks\n00079| class ResultCache {\n00080|   private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n00081| \n00082|   set(key: string, data: any, ttlMinutes: number = 30): void {\n00083|     const timestamp = Date.now();\n00084|     const ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n00085|     this.cache.set(key, { data, timestamp, ttl });\n00086|   }\n00087| \n00088|   get(key: string): any | null {\n00089|     const entry = this.cache.get(key);\n00090|     if (!entry) return null;\n00091| \n00092|     const now = Date.now();\n00093|     if (now - entry.timestamp > entry.ttl) {\n00094|       this.cache.delete(key);\n00095|       return null;\n00096|     }\n00097| \n00098|     return entry.data;\n00099|   }\n00100| \n00101|   clear(): void {\n00102|     this.cache.clear();\n00103|   }\n00104| \n00105|   // Clean up expired entries\n00106|   cleanup(): void {\n00107|     const now = Date.now();\n00108|     for (const [key, entry] of Array.from(this.cache.entries())) {\n00109|       if (now - entry.timestamp > entry.ttl) {\n00110|         this.cache.delete(key);\n00111|       }\n00112|     }\n00113|   }\n00114| }\n00115| \n00116| export const resultCache = new ResultCache();\n00117| \n00118| // Clean up cache periodically\n00119| if (typeof window !== 'undefined') {\n00120|   setInterval(() => resultCache.cleanup(), 5 * 60 * 1000); // Every 5 minutes\n00121| }\n00122| \n00123| /**\n00124|  * Categorize error based on response or error object\n00125|  */\n00126| export function categorizeError(error: any, response?: Response): ErrorType {\n00127|   if (!navigator.onLine) return ErrorType.NETWORK;\n00128| \n00129|   if (response) {\n00130|     if (response.status === 429) return ErrorType.RATE_LIMIT;\n00131|     if (response.status >= 400 && response.status < 500) return ErrorType.VALIDATION;\n00132|     if (response.status >= 500) return ErrorType.SERVER;\n00133|     if (response.status === 408 || response.status === 504) return ErrorType.TIMEOUT;\n00134|   }\n00135| \n00136|   if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n00137|   if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n00138|   if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n00139| \n00140|   return ErrorType.UNKNOWN;\n00141| }\n00142| \n00143| /**\n00144|  * Calculate delay for exponential backoff\n00145|  */\n00146| export function calculateDelay(attempt: number, config: RetryConfig): number {\n00147|   const delay = config.baseDelay * Math.pow(config.backoffFactor, attempt - 1);\n00148|   const jitter = Math.random() * 0.1 * delay; // Add 10% jitter\n00149|   return Math.min(delay + jitter, config.maxDelay);\n00150| }\n00151| \n00152| /**\n00153|  * Sleep for specified milliseconds\n00154|  */\n00155| export function sleep(ms: number): Promise<void> {\n00156|   return new Promise(resolve => setTimeout(resolve, ms));\n00157| }\n00158| \n00159| /**\n00160|  * Execute operation with retry logic and error handling\n00161|  */\n00162| export async function withErrorHandling<T>(\n00163|   operation: () => Promise<T>,\n00164|   context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n00165|   retryConfig: Partial<RetryConfig> = {},\n00166|   cacheKey?: string\n00167| ): Promise<T | ErrorResult> {\n00168|   const config = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };\n00169|   const fullContext: ErrorContext = {\n00170|     ...context,\n00171|     timestamp: new Date().toISOString(),\n00172|     userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n00173|     url: typeof window !== 'undefined' ? window.location.href : undefined\n00174|   };\n00175| \n00176|   // Check cache first for fallback data\n00177|   const cachedResult = cacheKey ? resultCache.get(cacheKey) : null;\n00178| \n00179|   for (let attempt = 1; attempt <= config.maxRetries + 1; attempt++) {\n00180|     try {\n00181|       fullContext.retryCount = attempt - 1;\n00182|       const result = await operation();\n00183| \n00184|       // Cache successful results\n00185|       if (cacheKey && result) {\n00186|         resultCache.set(cacheKey, result);\n00187|       }\n00188| \n00189|       return result;\n00190|     } catch (error: any) {\n00191|       const errorType = categorizeError(error, error.response);\n00192| \n00193|       console.error(`[ErrorHandler] Attempt ${attempt}/${config.maxRetries + 1} failed:`, {\n00194|         error: error.message,\n00195|         type: errorType,\n00196|         context: fullContext\n00197|       });\n00198| \n00199|       // If this is the last attempt or error is not retryable\n00200|       if (attempt > config.maxRetries || !config.retryableErrors.includes(errorType)) {\n00201|         const errorResult: ErrorResult = {\n00202|           success: false,\n00203|           error: {\n00204|             type: errorType,\n00205|             message: error.message || 'Unknown error',\n00206|             userMessage: USER_MESSAGES[errorType],\n00207|             technicalDetails: process.env.NODE_ENV === 'development' ? error : undefined,\n00208|             context: fullContext,\n00209|             retryable: config.retryableErrors.includes(errorType),\n00210|             suggestedAction: SUGGESTED_ACTIONS[errorType]\n00211|           }\n00212|         };\n00213| \n00214|         // Add fallback data from cache if available\n00215|         if (cachedResult) {\n00216|           errorResult.fallbackData = cachedResult;\n00217|           errorResult.error.userMessage += ' Показаны последние актуальные данные.';\n00218|         }\n00219| \n00220|         return errorResult;\n00221|       }\n00222| \n00223|       // Wait before retrying\n00224|       const delay = calculateDelay(attempt, config);\n00225|       console.log(`[ErrorHandler] Retrying in ${delay}ms...`);\n00226|       await sleep(delay);\n00227|     }\n00228|   }\n00229| \n00230|   // This should never be reached, but TypeScript requires it\n00231|   return {\n00232|     success: false,\n00233|     error: {\n00234|       type: ErrorType.UNKNOWN,\n00235|       message: 'Unexpected error in retry logic',\n00236|       userMessage: USER_MESSAGES[ErrorType.UNKNOWN],\n00237|       context: fullContext,\n00238|       retryable: false\n00239|     }\n00240|   };\n00241| }\n00242| \n00243| /**\n00244|  * Enhanced API request with error handling and caching\n00245|  */\n00246| export async function apiRequestWithErrorHandling(\n00247|   endpoint: string,\n00248|   options: RequestInit = {},\n00249|   context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n00250|   retryConfig?: Partial<RetryConfig>,\n00251|   cacheKey?: string\n00252| ): Promise<any | ErrorResult> {\n00253|   return withErrorHandling(\n00254|     () => apiRequestWithTimeout(endpoint, options),\n00255|     context,\n00256|     retryConfig,\n00257|     cacheKey\n00258|   );\n00259| }\n00260| \n00261| /**\n00262|  * Graceful degradation helper for UI components\n00263|  * Note: This function is not currently used and would need to be moved to a .tsx file if implemented\n00264|  */\n00265| export function withGracefulDegradation<T>(\n00266|   Component: React.ComponentType<T>,\n00267|   FallbackComponent: React.ComponentType<{ error: ErrorResult }>\n00268| ) {\n00269|   return function GracefulComponent(props: T) {\n00270|     // This would be used in error boundaries\n00271|     // For now, just return the original component\n00272|     return Component;\n00273|   };\n00274| }\n00275| \n00276| // Error boundary component removed - should be implemented in a .tsx file if needed\n\n(End of file - total 276 lines)\n</file>",
    "title": "lib/error-handling.ts",
    "metadata": {
      "preview": "import { apiRequestWithTimeout } from './api-utils';\n\n// Error types for better categorization\nexport enum ErrorType {\n  NETWORK = 'NETWORK',\n  API = 'API',\n  VALIDATION = 'VALIDATION',\n  TIMEOUT = 'TIMEOUT',\n  RATE_LIMIT = 'RATE_LIMIT',\n  SERVER = 'SERVER',\n  UNKNOWN = 'UNKNOWN'\n}\n\nexport interface ErrorContext {\n  operation: string;\n  company?: string;\n  requestId?: string;\n  userId?: string;\n  timestamp: string;\n  retryCount?: number;"
    },
    "time": {
      "start": 1765814285499,
      "end": 1765814285502
    }
  }
}