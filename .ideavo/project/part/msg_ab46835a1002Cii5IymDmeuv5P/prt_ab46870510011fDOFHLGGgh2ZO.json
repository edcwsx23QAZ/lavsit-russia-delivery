{
  "id": "prt_ab46870510011fDOFHLGGgh2ZO",
  "sessionID": "ses_54b97e247ffenCZZa4jZiIWD0l",
  "messageID": "msg_ab46835a1002Cii5IymDmeuv5P",
  "type": "tool",
  "callID": "call_fb93296fc0194140b364b562",
  "tool": "read",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/lib/api-utils.ts"
    },
    "output": "<file>\n00001| export interface ApiRequestConfig {\n00002|   timeout?: number;\n00003|   retries?: number;\n00004|   retryDelay?: number;\n00005| }\n00006| \n00007| export class ApiTimeoutError extends Error {\n00008|   constructor(message: string, public readonly timeoutMs: number) {\n00009|     super(message);\n00010|     this.name = 'ApiTimeoutError';\n00011|   }\n00012| }\n00013| \n00014| export class ApiValidationError extends Error {\n00015|   constructor(message: string, public readonly field?: string) {\n00016|     super(message);\n00017|     this.name = 'ApiValidationError';\n00018|   }\n00019| }\n00020| \n00021| export async function apiRequestWithTimeout(\n00022|   url: string,\n00023|   options: RequestInit = {},\n00024|   config: ApiRequestConfig = {}\n00025| ): Promise<Response> {\n00026|   const { timeout = 10000 } = config;\n00027| \n00028|   const controller = new AbortController();\n00029|   const timeoutId = setTimeout(() => controller.abort(), timeout);\n00030| \n00031|   const requestOptions: RequestInit = {\n00032|     ...options,\n00033|     signal: controller.signal,\n00034|   };\n00035| \n00036|   try {\n00037|     const response = await fetch(url, requestOptions);\n00038|     clearTimeout(timeoutId);\n00039|     return response;\n00040|   } catch (error) {\n00041|     clearTimeout(timeoutId);\n00042| \n00043|     if (error instanceof Error && error.name === 'AbortError') {\n00044|       throw new ApiTimeoutError(`Request timeout after ${timeout}ms`, timeout);\n00045|     }\n00046| \n00047|     throw error;\n00048|   }\n00049| }\n00050| \n00051| /**\n00052|  * Enhanced API request with comprehensive error handling and caching\n00053|  */\n00054| export async function enhancedApiRequest(\n00055|   url: string,\n00056|   options: RequestInit = {},\n00057|   context: { operation: string; company?: string },\n00058|   retryConfig?: Partial<{ maxRetries: number; baseDelay: number }>\n00059| ) {\n00060|   const { apiRequestWithErrorHandling } = await import('./error-handling');\n00061| \n00062|   return apiRequestWithErrorHandling(\n00063|     url,\n00064|     options,\n00065|     context,\n00066|     retryConfig,\n00067|     `${context.company || 'unknown'}_${context.operation}_${JSON.stringify(options.body || {})}`\n00068|   );\n00069| }\n00070| \n00071| export function validateApiInput(data: any, rules: Record<string, (value: any) => string | null>): void {\n00072|   for (const [field, validator] of Object.entries(rules)) {\n00073|     const error = validator(data[field]);\n00074|     if (error) {\n00075|       throw new ApiValidationError(error, field);\n00076|     }\n00077|   }\n00078| }\n00079| \n00080| // Common validation rules\n00081| export const validationRules = {\n00082|   required: (field: string) => (value: any) => \n00083|     value == null || value === '' ? `${field} is required` : null,\n00084|   \n00085|   minLength: (field: string, min: number) => (value: string) =>\n00086|     value && value.length < min ? `${field} must be at least ${min} characters` : null,\n00087|   \n00088|   maxLength: (field: string, max: number) => (value: string) =>\n00089|     value && value.length > max ? `${field} must be less than ${max} characters` : null,\n00090|   \n00091|   number: (field: string) => (value: any) =>\n00092|     value != null && isNaN(Number(value)) ? `${field} must be a number` : null,\n00093|   \n00094|   positive: (field: string) => (value: number) =>\n00095|     value != null && value <= 0 ? `${field} must be positive` : null,\n00096|   \n00097|   email: (field: string) => (value: string) =>\n00098|     value && !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) ? `${field} must be a valid email` : null,\n00099| };\n00100| \n00101| // Performance monitoring utilities\n00102| export class PerformanceMonitor {\n00103|   private static measurements: Map<string, number[]> = new Map();\n00104|   \n00105|   static startMeasurement(key: string): () => number {\n00106|     const start = performance.now();\n00107|     return () => {\n00108|       const duration = performance.now() - start;\n00109|       this.recordMeasurement(key, duration);\n00110|       return duration;\n00111|     };\n00112|   }\n00113|   \n00114|   static recordMeasurement(key: string, duration: number): void {\n00115|     if (!this.measurements.has(key)) {\n00116|       this.measurements.set(key, []);\n00117|     }\n00118|     const measurements = this.measurements.get(key)!;\n00119|     measurements.push(duration);\n00120|     \n00121|     // Keep only last 100 measurements to prevent memory leaks\n00122|     if (measurements.length > 100) {\n00123|       measurements.shift();\n00124|     }\n00125|   }\n00126|   \n00127|   static getAverageTime(key: string): number {\n00128|     const measurements = this.measurements.get(key) || [];\n00129|     if (measurements.length === 0) return 0;\n00130|     return measurements.reduce((sum, time) => sum + time, 0) / measurements.length;\n00131|   }\n00132|   \n00133|   static getMetrics(): Record<string, { average: number; count: number; latest: number }> {\n00134|     const metrics: Record<string, { average: number; count: number; latest: number }> = {};\n00135|     \n00136|     this.measurements.forEach((measurements, key) => {\n00137|       if (measurements.length > 0) {\n00138|         const average = measurements.reduce((sum, time) => sum + time, 0) / measurements.length;\n00139|         metrics[key] = {\n00140|           average: Math.round(average * 100) / 100,\n00141|           count: measurements.length,\n00142|           latest: Math.round(measurements[measurements.length - 1] * 100) / 100,\n00143|         };\n00144|       }\n00145|     });\n00146|     \n00147|     return metrics;\n00148|   }\n00149|   \n00150|   static clearMetrics(): void {\n00151|     this.measurements.clear();\n00152|   }\n00153| }\n</file>",
    "title": "lib/api-utils.ts",
    "metadata": {
      "preview": "export interface ApiRequestConfig {\n  timeout?: number;\n  retries?: number;\n  retryDelay?: number;\n}\n\nexport class ApiTimeoutError extends Error {\n  constructor(message: string, public readonly timeoutMs: number) {\n    super(message);\n    this.name = 'ApiTimeoutError';\n  }\n}\n\nexport class ApiValidationError extends Error {\n  constructor(message: string, public readonly field?: string) {\n    super(message);\n    this.name = 'ApiValidationError';\n  }\n}\n"
    },
    "time": {
      "start": 1763963334739,
      "end": 1763963334741
    }
  }
}