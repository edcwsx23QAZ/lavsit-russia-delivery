{
  "id": "prt_9e31f30da001kHIoKt7Q6mlLlc",
  "messageID": "msg_9e31f2204002vftTmkMz8cJsIl",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "edit",
  "callID": "call_62763041",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "lib/api-utils.ts",
      "oldString": "export async function apiRequestWithTimeout(\n  url: string,\n  options: RequestInit = {},\n  config: ApiRequestConfig = {}\n): Promise<Response> {\n  const { timeout = 10000 } = config;\n  \n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n  \n  const requestOptions: RequestInit = {\n    ...options,\n    signal: controller.signal,\n  };\n\n  try {\n    const response = await fetch(url, requestOptions);\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n    \n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new ApiTimeoutError(`Request timeout after ${timeout}ms`, timeout);\n    }\n    \n    throw error;\n  }\n}",
      "newString": "export async function apiRequestWithTimeout(\n  url: string,\n  options: RequestInit = {},\n  config: ApiRequestConfig = {}\n): Promise<Response> {\n  const { timeout = 10000 } = config;\n\n  const controller = new AbortController();\n  const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n  const requestOptions: RequestInit = {\n    ...options,\n    signal: controller.signal,\n  };\n\n  try {\n    const response = await fetch(url, requestOptions);\n    clearTimeout(timeoutId);\n    return response;\n  } catch (error) {\n    clearTimeout(timeoutId);\n\n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new ApiTimeoutError(`Request timeout after ${timeout}ms`, timeout);\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Enhanced API request with comprehensive error handling and caching\n */\nexport async function enhancedApiRequest(\n  url: string,\n  options: RequestInit = {},\n  context: { operation: string; company?: string },\n  retryConfig?: Partial<{ maxRetries: number; baseDelay: number }>\n) {\n  const { apiRequestWithErrorHandling } = await import('./error-handling');\n\n  return apiRequestWithErrorHandling(\n    url,\n    options,\n    context,\n    retryConfig,\n    `${context.company || 'unknown'}_${context.operation}_${JSON.stringify(options.body || {})}`\n  );\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "diff": "Index: /home/user/project/lib/api-utils.ts\n===================================================================\n--- /home/user/project/lib/api-utils.ts\n+++ /home/user/project/lib/api-utils.ts\n@@ -47,8 +47,28 @@\n     throw error;\n   }\n }\n \n+/**\n+ * Enhanced API request with comprehensive error handling and caching\n+ */\n+export async function enhancedApiRequest(\n+  url: string,\n+  options: RequestInit = {},\n+  context: { operation: string; company?: string },\n+  retryConfig?: Partial<{ maxRetries: number; baseDelay: number }>\n+) {\n+  const { apiRequestWithErrorHandling } = await import('./error-handling');\n+\n+  return apiRequestWithErrorHandling(\n+    url,\n+    options,\n+    context,\n+    retryConfig,\n+    `${context.company || 'unknown'}_${context.operation}_${JSON.stringify(options.body || {})}`\n+  );\n+}\n+\n export function validateApiInput(data: any, rules: Record<string, (value: any) => string | null>): void {\n   for (const [field, validator] of Object.entries(rules)) {\n     const error = validator(data[field]);\n     if (error) {\n"
    },
    "title": "lib/api-utils.ts",
    "time": {
      "start": 1760452096220,
      "end": 1760452096224
    }
  }
}