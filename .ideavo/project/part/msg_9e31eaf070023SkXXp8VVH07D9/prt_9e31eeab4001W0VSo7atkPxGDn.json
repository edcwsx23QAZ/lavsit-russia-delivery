{
  "id": "prt_9e31eeab4001W0VSo7atkPxGDn",
  "messageID": "msg_9e31eaf070023SkXXp8VVH07D9",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "call_16419201",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "lib/error-handling.ts",
      "content": "import { apiRequestWithTimeout } from './api-utils';\n\n// Error types for better categorization\nexport enum ErrorType {\n  NETWORK = 'NETWORK',\n  API = 'API',\n  VALIDATION = 'VALIDATION',\n  TIMEOUT = 'TIMEOUT',\n  RATE_LIMIT = 'RATE_LIMIT',\n  SERVER = 'SERVER',\n  UNKNOWN = 'UNKNOWN'\n}\n\nexport interface ErrorContext {\n  operation: string;\n  company?: string;\n  requestId?: string;\n  userId?: string;\n  timestamp: string;\n  retryCount?: number;\n  userAgent?: string;\n  url?: string;\n}\n\nexport interface RetryConfig {\n  maxRetries: number;\n  baseDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n  retryableErrors: ErrorType[];\n}\n\nexport interface ErrorResult {\n  success: false;\n  error: {\n    type: ErrorType;\n    message: string;\n    userMessage: string;\n    technicalDetails?: any;\n    context: ErrorContext;\n    retryable: boolean;\n    suggestedAction?: string;\n  };\n  fallbackData?: any;\n}\n\n// Default retry configuration\nconst DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  baseDelay: 1000, // 1 second\n  maxDelay: 30000, // 30 seconds\n  backoffFactor: 2,\n  retryableErrors: [ErrorType.NETWORK, ErrorType.TIMEOUT, ErrorType.SERVER, ErrorType.RATE_LIMIT]\n};\n\n// User-friendly error messages\nconst USER_MESSAGES = {\n  [ErrorType.NETWORK]: 'Проблемы с подключением к интернету. Проверьте соединение и попробуйте снова.',\n  [ErrorType.API]: 'Временные проблемы с сервисом транспортной компании. Попробуйте позже.',\n  [ErrorType.VALIDATION]: 'Проверьте правильность введенных данных.',\n  [ErrorType.TIMEOUT]: 'Сервис отвечает слишком долго. Попробуйте еще раз.',\n  [ErrorType.RATE_LIMIT]: 'Слишком много запросов. Подождите немного и попробуйте снова.',\n  [ErrorType.SERVER]: 'Временные технические проблемы. Попробуйте позже.',\n  [ErrorType.UNKNOWN]: 'Произошла неожиданная ошибка. Попробуйте еще раз.'\n};\n\n// Suggested actions for different error types\nconst SUGGESTED_ACTIONS = {\n  [ErrorType.NETWORK]: 'Проверьте интернет-соединение',\n  [ErrorType.API]: 'Попробуйте выбрать другую транспортную компанию',\n  [ErrorType.VALIDATION]: 'Проверьте корректность адресов и параметров груза',\n  [ErrorType.TIMEOUT]: 'Попробуйте упростить запрос или выбрать меньшее количество грузов',\n  [ErrorType.RATE_LIMIT]: 'Подождите 1-2 минуты перед следующим запросом',\n  [ErrorType.SERVER]: 'Свяжитесь с поддержкой если проблема persists',\n  [ErrorType.UNKNOWN]: 'Свяжитесь с поддержкой'\n};\n\n// Cache for storing successful results to provide fallbacks\nclass ResultCache {\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  set(key: string, data: any, ttlMinutes: number = 30): void {\n    const timestamp = Date.now();\n    const ttl = ttlMinutes * 60 * 1000; // Convert to milliseconds\n    this.cache.set(key, { data, timestamp, ttl });\n  }\n\n  get(key: string): any | null {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n\n    const now = Date.now();\n    if (now - entry.timestamp > entry.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return entry.data;\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  // Clean up expired entries\n  cleanup(): void {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp > entry.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n\nexport const resultCache = new ResultCache();\n\n// Clean up cache periodically\nif (typeof window !== 'undefined') {\n  setInterval(() => resultCache.cleanup(), 5 * 60 * 1000); // Every 5 minutes\n}\n\n/**\n * Categorize error based on response or error object\n */\nexport function categorizeError(error: any, response?: Response): ErrorType {\n  if (!navigator.onLine) return ErrorType.NETWORK;\n\n  if (response) {\n    if (response.status === 429) return ErrorType.RATE_LIMIT;\n    if (response.status >= 400 && response.status < 500) return ErrorType.VALIDATION;\n    if (response.status >= 500) return ErrorType.SERVER;\n    if (response.status === 408 || response.status === 504) return ErrorType.TIMEOUT;\n  }\n\n  if (error instanceof TypeError && error.message.includes('fetch')) return ErrorType.NETWORK;\n  if (error.name === 'AbortError') return ErrorType.TIMEOUT;\n  if (error.message?.includes('timeout')) return ErrorType.TIMEOUT;\n\n  return ErrorType.UNKNOWN;\n}\n\n/**\n * Calculate delay for exponential backoff\n */\nexport function calculateDelay(attempt: number, config: RetryConfig): number {\n  const delay = config.baseDelay * Math.pow(config.backoffFactor, attempt - 1);\n  const jitter = Math.random() * 0.1 * delay; // Add 10% jitter\n  return Math.min(delay + jitter, config.maxDelay);\n}\n\n/**\n * Sleep for specified milliseconds\n */\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Execute operation with retry logic and error handling\n */\nexport async function withErrorHandling<T>(\n  operation: () => Promise<T>,\n  context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n  retryConfig: Partial<RetryConfig> = {},\n  cacheKey?: string\n): Promise<T | ErrorResult> {\n  const config = { ...DEFAULT_RETRY_CONFIG, ...retryConfig };\n  const fullContext: ErrorContext = {\n    ...context,\n    timestamp: new Date().toISOString(),\n    userAgent: typeof navigator !== 'undefined' ? navigator.userAgent : undefined,\n    url: typeof window !== 'undefined' ? window.location.href : undefined\n  };\n\n  // Check cache first for fallback data\n  const cachedResult = cacheKey ? resultCache.get(cacheKey) : null;\n\n  for (let attempt = 1; attempt <= config.maxRetries + 1; attempt++) {\n    try {\n      fullContext.retryCount = attempt - 1;\n      const result = await operation();\n\n      // Cache successful results\n      if (cacheKey && result) {\n        resultCache.set(cacheKey, result);\n      }\n\n      return result;\n    } catch (error: any) {\n      const errorType = categorizeError(error, error.response);\n\n      console.error(`[ErrorHandler] Attempt ${attempt}/${config.maxRetries + 1} failed:`, {\n        error: error.message,\n        type: errorType,\n        context: fullContext\n      });\n\n      // If this is the last attempt or error is not retryable\n      if (attempt > config.maxRetries || !config.retryableErrors.includes(errorType)) {\n        const errorResult: ErrorResult = {\n          success: false,\n          error: {\n            type: errorType,\n            message: error.message || 'Unknown error',\n            userMessage: USER_MESSAGES[errorType],\n            technicalDetails: process.env.NODE_ENV === 'development' ? error : undefined,\n            context: fullContext,\n            retryable: config.retryableErrors.includes(errorType),\n            suggestedAction: SUGGESTED_ACTIONS[errorType]\n          }\n        };\n\n        // Add fallback data from cache if available\n        if (cachedResult) {\n          errorResult.fallbackData = cachedResult;\n          errorResult.error.userMessage += ' Показаны последние актуальные данные.';\n        }\n\n        return errorResult;\n      }\n\n      // Wait before retrying\n      const delay = calculateDelay(attempt, config);\n      console.log(`[ErrorHandler] Retrying in ${delay}ms...`);\n      await sleep(delay);\n    }\n  }\n\n  // This should never be reached, but TypeScript requires it\n  return {\n    success: false,\n    error: {\n      type: ErrorType.UNKNOWN,\n      message: 'Unexpected error in retry logic',\n      userMessage: USER_MESSAGES[ErrorType.UNKNOWN],\n      context: fullContext,\n      retryable: false\n    }\n  };\n}\n\n/**\n * Enhanced API request with error handling and caching\n */\nexport async function apiRequestWithErrorHandling(\n  endpoint: string,\n  options: RequestInit = {},\n  context: Omit<ErrorContext, 'timestamp' | 'retryCount'>,\n  retryConfig?: Partial<RetryConfig>,\n  cacheKey?: string\n): Promise<any | ErrorResult> {\n  return withErrorHandling(\n    () => apiRequestWithTimeout(endpoint, options),\n    context,\n    retryConfig,\n    cacheKey\n  );\n}\n\n/**\n * Graceful degradation helper for UI components\n */\nexport function withGracefulDegradation<T>(\n  Component: React.ComponentType<T>,\n  FallbackComponent: React.ComponentType<{ error: ErrorResult }>\n) {\n  return function GracefulComponent(props: T) {\n    // This would be used in error boundaries\n    // For now, just return the original component\n    return <Component {...props} />;\n  };\n}\n\n/**\n * Error boundary component for React components\n */\nexport class ErrorBoundary extends React.Component<\n  { children: React.ReactNode; fallback?: React.ComponentType<{ error: any }> },\n  { hasError: boolean; error: any }\n> {\n  constructor(props: any) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: any) {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: any, errorInfo: any) {\n    console.error('[ErrorBoundary] Caught error:', error, errorInfo);\n\n    // Report to monitoring service\n    if (typeof window !== 'undefined' && (window as any).Sentry) {\n      (window as any).Sentry.captureException(error, {\n        contexts: {\n          react: {\n            componentStack: errorInfo.componentStack\n          }\n        }\n      });\n    }\n  }\n\n  render() {\n    if (this.state.hasError) {\n      const FallbackComponent = this.props.fallback;\n      if (FallbackComponent) {\n        return <FallbackComponent error={this.state.error} />;\n      }\n\n      return (\n        <div className=\"p-4 border border-red-300 bg-red-50 rounded-lg\">\n          <h3 className=\"text-lg font-semibold text-red-800 mb-2\">\n            Что-то пошло не так\n          </h3>\n          <p className=\"text-red-600 mb-4\">\n            Произошла ошибка при загрузке компонента. Попробуйте перезагрузить страницу.\n          </p>\n          <button\n            onClick={() => window.location.reload()}\n            className=\"px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700\"\n          >\n            Перезагрузить\n          </button>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/lib/error-handling.ts",
      "exists": false
    },
    "title": "lib/error-handling.ts",
    "time": {
      "start": 1760452078264,
      "end": 1760452078265
    }
  }
}