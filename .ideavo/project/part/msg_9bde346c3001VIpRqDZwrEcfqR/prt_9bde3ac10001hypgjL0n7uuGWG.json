{
  "id": "prt_9bde3ac10001hypgjL0n7uuGWG",
  "messageID": "msg_9bde346c3001VIpRqDZwrEcfqR",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01LMJMDECZtDaxWWUUL8RmB4",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/app/api/dadata/route.ts",
      "content": "import { NextRequest, NextResponse } from 'next/server';\n\nconst DADATA_API_KEY = 'eb87bbb3789bb43ed465f796892ea951f9e91008';\nconst DADATA_SECRET_KEY = '90f3541a30ef6e1c40e665b69f1aa6d74242c3f2';\n\n// –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞ —á–µ—Ä–µ–∑ DaData\nexport async function POST(request: NextRequest) {\n  try {\n    const { address, type = 'clean' } = await request.json();\n\n    if (!address) {\n      return NextResponse.json(\n        { error: 'Address is required' },\n        { status: 400 }\n      );\n    }\n\n    console.log('üåê DaData –∑–∞–ø—Ä–æ—Å:', { address, type });\n\n    let url = '';\n    let body: any = '';\n    let headers: HeadersInit = {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json',\n      'Authorization': `Token ${DADATA_API_KEY}`,\n    };\n\n    if (type === 'clean') {\n      // –û—á–∏—Å—Ç–∫–∞ –∏ –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∞–¥—Ä–µ—Å–∞\n      url = 'https://cleaner.dadata.ru/api/v1/clean/address';\n      body = JSON.stringify([address]);\n      headers['X-Secret'] = DADATA_SECRET_KEY;\n    } else if (type === 'suggest') {\n      // –ü–æ–¥—Å–∫–∞–∑–∫–∏ –∞–¥—Ä–µ—Å–æ–≤\n      url = 'https://suggestions.dadata.ru/suggestions/api/4_1/rs/suggest/address';\n      body = JSON.stringify({\n        query: address,\n        count: 10\n      });\n    }\n\n    console.log('üåê DaData URL:', url);\n    console.log('üåê DaData Body:', body);\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body\n    });\n\n    const data = await response.json();\n    \n    console.log('üåê DaData response status:', response.status);\n    console.log('üåê DaData response:', JSON.stringify(data, null, 2));\n\n    if (!response.ok) {\n      console.error('‚ùå DaData API error:', data);\n      return NextResponse.json(\n        { error: 'DaData API error', details: data },\n        { status: response.status }\n      );\n    }\n\n    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç–≤–µ—Ç–∞ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∑–∞–ø—Ä–æ—Å–∞\n    if (type === 'clean' && Array.isArray(data) && data.length > 0) {\n      const cleanedAddress = data[0];\n      \n      // –§–æ—Ä–º–∏—Ä—É–µ–º –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å –¥–ª—è –î–µ–ª–æ–≤—ã—Ö –õ–∏–Ω–∏–π\n      const dellinFormat = formatAddressForDellin(cleanedAddress);\n      \n      return NextResponse.json({\n        success: true,\n        data: {\n          original: address,\n          cleaned: cleanedAddress,\n          dellinFormat,\n          region_kladr_id: cleanedAddress.region_kladr_id,\n          city_kladr_id: cleanedAddress.city_kladr_id,\n          street_kladr_id: cleanedAddress.street_kladr_id\n        }\n      });\n    } else if (type === 'suggest' && data.suggestions && Array.isArray(data.suggestions)) {\n      const suggestions = data.suggestions.map((suggestion: any) => ({\n        value: suggestion.value,\n        unrestricted_value: suggestion.unrestricted_value,\n        data: suggestion.data,\n        dellinFormat: formatAddressForDellin(suggestion.data)\n      }));\n\n      return NextResponse.json({\n        success: true,\n        data: suggestions\n      });\n    }\n\n    return NextResponse.json({\n      success: false,\n      error: 'Invalid response format',\n      data\n    });\n\n  } catch (error) {\n    console.error('‚ùå DaData API error:', error);\n    return NextResponse.json(\n      { \n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}\n\n// –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –¥–ª—è API –î–µ–ª–æ–≤—ã—Ö –õ–∏–Ω–∏–π\nfunction formatAddressForDellin(addressData: any): string {\n  const parts: string[] = [];\n  \n  // –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–≥–∏–æ–Ω —Å —Ç–∏–ø–æ–º\n  if (addressData.region_with_type) {\n    parts.push(addressData.region_with_type);\n  }\n  \n  // –î–æ–±–∞–≤–ª—è–µ–º –≥–æ—Ä–æ–¥ —Å —Ç–∏–ø–æ–º\n  if (addressData.city_with_type) {\n    parts.push(addressData.city_with_type);\n  } else if (addressData.settlement_with_type) {\n    parts.push(addressData.settlement_with_type);\n  }\n  \n  // –î–æ–±–∞–≤–ª—è–µ–º —É–ª–∏—Ü—É —Å —Ç–∏–ø–æ–º\n  if (addressData.street_with_type) {\n    parts.push(addressData.street_with_type);\n  }\n  \n  // –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–º\n  if (addressData.house) {\n    let houseStr = `–¥. ${addressData.house}`;\n    \n    // –î–æ–±–∞–≤–ª—è–µ–º –∫–æ—Ä–ø—É—Å –µ—Å–ª–∏ –µ—Å—Ç—å\n    if (addressData.block) {\n      houseStr += `, –∫–æ—Ä–ø. ${addressData.block}`;\n    }\n    \n    parts.push(houseStr);\n  }\n  \n  const formatted = parts.join(', ');\n  console.log('üè† Formatted address for Dellin:', formatted);\n  \n  return formatted || addressData.result || '';\n}\n\n// –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –≥–æ—Ä–æ–¥–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ç–µ—Ä–º–∏–Ω–∞–ª–æ–≤\nexport async function GET(request: NextRequest) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const cityName = searchParams.get('city');\n\n    if (!cityName) {\n      return NextResponse.json(\n        { error: 'City name is required' },\n        { status: 400 }\n      );\n    }\n\n    console.log('üèôÔ∏è DaData city search:', cityName);\n\n    const response = await fetch('https://suggestions.dadata.ru/suggestions/api/4_1/rs/suggest/address', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n        'Authorization': `Token ${DADATA_API_KEY}`,\n      },\n      body: JSON.stringify({\n        query: cityName,\n        count: 5,\n        locations: [{ country: '*' }],\n        restrict_value: true\n      })\n    });\n\n    const data = await response.json();\n    \n    console.log('üèôÔ∏è DaData city response:', JSON.stringify(data, null, 2));\n\n    if (!response.ok) {\n      return NextResponse.json(\n        { error: 'DaData API error', details: data },\n        { status: response.status }\n      );\n    }\n\n    if (data.suggestions && Array.isArray(data.suggestions)) {\n      const cities = data.suggestions\n        .filter((s: any) => s.data.city || s.data.settlement)\n        .map((suggestion: any) => ({\n          value: suggestion.value,\n          city: suggestion.data.city || suggestion.data.settlement,\n          region: suggestion.data.region,\n          city_kladr_id: suggestion.data.city_kladr_id || suggestion.data.settlement_kladr_id,\n          region_kladr_id: suggestion.data.region_kladr_id,\n          dellinFormat: formatAddressForDellin(suggestion.data)\n        }));\n\n      return NextResponse.json({\n        success: true,\n        data: cities\n      });\n    }\n\n    return NextResponse.json({\n      success: false,\n      error: 'No cities found'\n    });\n\n  } catch (error) {\n    console.error('‚ùå DaData city search error:', error);\n    return NextResponse.json(\n      { \n        error: 'Internal server error',\n        details: error instanceof Error ? error.message : 'Unknown error'\n      },\n      { status: 500 }\n    );\n  }\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/app/api/dadata/route.ts",
      "exists": false
    },
    "title": "app/api/dadata/route.ts",
    "time": {
      "start": 1759827462458,
      "end": 1759827462462
    }
  }
}