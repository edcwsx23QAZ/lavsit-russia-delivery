{
  "id": "prt_99491feba001X9qdT20B9Owmn6",
  "messageID": "msg_9949153ca001bC1haFGCrVYHYy",
  "sessionID": "ses_6852784ecffeuHwynj83p2lr14",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01VNKHLAWnkQUJ4xekcsepue",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/TruckVisualization.tsx",
      "content": "'use client';\n\nimport React from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Truck } from 'lucide-react';\n\ninterface Cargo {\n  id: string;\n  length: number; // в мм\n  width: number;  // в мм\n  height: number; // в мм\n  weight: number;\n  productName?: string;\n}\n\ninterface Orientation {\n  length: number;\n  width: number;\n  height: number;\n  rotationAngle: number; // в градусах\n  flipped: boolean; // перевернут ли груз по высоте\n}\n\ninterface CargoPlacement {\n  cargo: Cargo;\n  x: number;\n  y: number;\n  z: number;\n  orientation: Orientation;\n  color: string;\n  projectedVertices: Array<{x: number, y: number}>; // Для 3D отображения\n}\n\ninterface TruckVisualizationProps {\n  cargos: Cargo[];\n  isVisible?: boolean;\n}\n\n// Размеры кузова в мм\nconst TRUCK_DIMENSIONS = {\n  length: 4200,\n  width: 2025,\n  height: 2025\n};\n\n// Углы поворота для размещения грузов (в градусах)\nconst ROTATION_ANGLES = [0, 45, 90, 135, 180, 225, 270, 315];\n\n// Цвета для разных грузов\nconst CARGO_COLORS = [\n  '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FECA57',\n  '#FF9FF3', '#54A0FF', '#5F27CD', '#00D2D3', '#FF9F43',\n  '#10AC84', '#EE5A24', '#0984E3', '#6C5CE7', '#FD79A8'\n];\n\nexport default function TruckVisualization({ cargos, isVisible = false }: TruckVisualizationProps) {\n  \n  // Функция проверки ключевых слов\n  const isChairOrSeat = (productName?: string) => {\n    if (!productName) return false;\n    const lowerName = productName.toLowerCase();\n    return lowerName.includes('стул') || lowerName.includes('кресло');\n  };\n\n  // Генерация всех возможных ориентаций груза\n  const generateOrientations = (cargo: Cargo): Orientation[] => {\n    const orientations: Orientation[] = [];\n    const baseDimensions = [\n      [cargo.length, cargo.width, cargo.height],\n      [cargo.width, cargo.length, cargo.height],\n      [cargo.length, cargo.height, cargo.width],\n      [cargo.height, cargo.length, cargo.width],\n      [cargo.width, cargo.height, cargo.length],\n      [cargo.height, cargo.width, cargo.length]\n    ];\n\n    // Для стульев/кресел ограничиваем повороты (нельзя переворачивать)\n    const allowedDimensions = isChairOrSeat(cargo.productName) \n      ? baseDimensions.slice(0, 2) // Только первые 2 варианта (без поворота по высоте)\n      : baseDimensions;\n\n    allowedDimensions.forEach(([l, w, h]) => {\n      ROTATION_ANGLES.forEach(angle => {\n        // Вычисляем размеры после поворота\n        const rad = (angle * Math.PI) / 180;\n        const cos = Math.abs(Math.cos(rad));\n        const sin = Math.abs(Math.sin(rad));\n        \n        const rotatedLength = l * cos + w * sin;\n        const rotatedWidth = l * sin + w * cos;\n\n        orientations.push({\n          length: rotatedLength,\n          width: rotatedWidth,\n          height: h,\n          rotationAngle: angle,\n          flipped: h !== cargo.height\n        });\n      });\n    });\n\n    return orientations;\n  };\n\n  // Проверка пересечения двух прямоугольников с учетом поворота\n  const checkCollision = (\n    x1: number, y1: number, x2: number, y2: number,\n    length1: number, width1: number, length2: number, width2: number,\n    angle1: number, angle2: number\n  ): boolean => {\n    // Упрощенная проверка через ограничивающие прямоугольники\n    const rad1 = (angle1 * Math.PI) / 180;\n    const rad2 = (angle2 * Math.PI) / 180;\n    \n    const cos1 = Math.abs(Math.cos(rad1));\n    const sin1 = Math.abs(Math.sin(rad1));\n    const cos2 = Math.abs(Math.cos(rad2));\n    const sin2 = Math.abs(Math.sin(rad2));\n    \n    const bbox1 = {\n      minX: x1,\n      maxX: x1 + length1 * cos1 + width1 * sin1,\n      minY: y1,\n      maxY: y1 + length1 * sin1 + width1 * cos1\n    };\n    \n    const bbox2 = {\n      minX: x2,\n      maxX: x2 + length2 * cos2 + width2 * sin2,\n      minY: y2,\n      maxY: y2 + length2 * sin2 + width2 * cos2\n    };\n\n    return !(bbox1.maxX <= bbox2.minX || bbox2.maxX <= bbox1.minX ||\n             bbox1.maxY <= bbox2.minY || bbox2.maxY <= bbox1.minY);\n  };\n\n  // Проверка валидности позиции\n  const isPositionValid = (\n    x: number, y: number, z: number,\n    orientation: Orientation,\n    placements: CargoPlacement[],\n    cargo: Cargo\n  ): boolean => {\n    \n    // Проверяем границы кузова\n    const rad = (orientation.rotationAngle * Math.PI) / 180;\n    const cos = Math.abs(Math.cos(rad));\n    const sin = Math.abs(Math.sin(rad));\n    \n    const effectiveLength = orientation.length * cos + orientation.width * sin;\n    const effectiveWidth = orientation.length * sin + orientation.width * cos;\n    \n    if (x + effectiveLength > TRUCK_DIMENSIONS.length || \n        y + effectiveWidth > TRUCK_DIMENSIONS.width ||\n        z + orientation.height > TRUCK_DIMENSIONS.height) {\n      return false;\n    }\n\n    // Проверяем пересечения с уже размещенными грузами\n    for (const placement of placements) {\n      // Проверка по высоте\n      if (!(z >= placement.z + placement.orientation.height || \n            z + orientation.height <= placement.z)) {\n        \n        // Если высоты пересекаются, проверяем пересечение по площади\n        if (checkCollision(\n          x, y, placement.x, placement.y,\n          orientation.length, orientation.width,\n          placement.orientation.length, placement.orientation.width,\n          orientation.rotationAngle, placement.orientation.rotationAngle\n        )) {\n          return false;\n        }\n      }\n    }\n\n    // Проверяем правила размещения\n    if (z > 0) { // Груз не на полу\n      const supportingCargos = placements.filter(p => \n        z === p.z + p.orientation.height && // Стоит прямо на другом грузе\n        !checkCollision(\n          x, y, p.x, p.y,\n          orientation.length, orientation.width,\n          p.orientation.length, p.orientation.width,\n          orientation.rotationAngle, p.orientation.rotationAngle\n        ) === false // Есть пересечение по площади (поддержка)\n      );\n\n      if (supportingCargos.length === 0) {\n        return false; // Должен на чем-то стоять\n      }\n\n      // Правило по весу\n      for (const supporting of supportingCargos) {\n        if (cargo.weight > supporting.cargo.weight) {\n          return false;\n        }\n      }\n\n      // Правила для стульев/кресел\n      if (isChairOrSeat(cargo.productName)) {\n        const allSupportingAreChairs = supportingCargos.every(p => \n          isChairOrSeat(p.cargo.productName)\n        );\n        \n        if (!allSupportingAreChairs) {\n          return false;\n        }\n\n        // Максимум 2 стула друг на друге\n        let chairLevels = 1;\n        let currentZ = z;\n        \n        while (currentZ > 0) {\n          const chairsBelow = placements.filter(p =>\n            p.z + p.orientation.height === currentZ &&\n            isChairOrSeat(p.cargo.productName)\n          );\n          \n          if (chairsBelow.length > 0) {\n            chairLevels++;\n            currentZ = Math.min(...chairsBelow.map(p => p.z));\n          } else {\n            break;\n          }\n        }\n        \n        if (chairLevels > 2) {\n          return false;\n        }\n      } else {\n        // Обычные грузы нельзя ставить на стулья\n        const hasChairSupport = supportingCargos.some(p => \n          isChairOrSeat(p.cargo.productName)\n        );\n        \n        if (hasChairSupport) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  };\n\n  // Расчет площади пола, занимаемой размещениями\n  const calculateFloorArea = (placements: CargoPlacement[], newPlacement?: CargoPlacement) => {\n    const allPlacements = newPlacement ? [...placements, newPlacement] : placements;\n    \n    if (allPlacements.length === 0) return 0;\n\n    let minX = Infinity, maxX = 0, minY = Infinity, maxY = 0;\n\n    allPlacements.forEach(p => {\n      const rad = (p.orientation.rotationAngle * Math.PI) / 180;\n      const cos = Math.abs(Math.cos(rad));\n      const sin = Math.abs(Math.sin(rad));\n      \n      const effectiveLength = p.orientation.length * cos + p.orientation.width * sin;\n      const effectiveWidth = p.orientation.length * sin + p.orientation.width * cos;\n      \n      minX = Math.min(minX, p.x);\n      maxX = Math.max(maxX, p.x + effectiveLength);\n      minY = Math.min(minY, p.y);\n      maxY = Math.max(maxY, p.y + effectiveWidth);\n    });\n\n    return (maxX - minX) * (maxY - minY);\n  };\n\n  // Основной алгоритм размещения\n  const calculateCargoPlacement = (): CargoPlacement[] => {\n    if (!cargos.length) return [];\n\n    // Фильтруем только заполненные грузы\n    const validCargos = cargos.filter(cargo => \n      cargo.length > 0 && cargo.width > 0 && cargo.height > 0 && cargo.weight > 0\n    );\n\n    if (!validCargos.length) return [];\n\n    // Сортировка: стулья первыми, потом по весу, потом по объему\n    const sortedCargos = [...validCargos].sort((a, b) => {\n      const aIsChair = isChairOrSeat(a.productName);\n      const bIsChair = isChairOrSeat(b.productName);\n      \n      if (aIsChair && !bIsChair) return -1;\n      if (!aIsChair && bIsChair) return 1;\n      \n      const weightDiff = b.weight - a.weight;\n      if (weightDiff !== 0) return weightDiff;\n      \n      const volumeA = a.length * a.width * a.height;\n      const volumeB = b.length * b.width * b.height;\n      return volumeB - volumeA;\n    });\n\n    const placements: CargoPlacement[] = [];\n\n    sortedCargos.forEach((cargo, index) => {\n      const color = CARGO_COLORS[index % CARGO_COLORS.length];\n      const orientations = generateOrientations(cargo);\n      \n      let bestPlacement: CargoPlacement | null = null;\n      let bestScore = Infinity;\n\n      // Генерируем возможные Z позиции\n      const possibleZ = [0];\n      placements.forEach(p => {\n        const topZ = p.z + p.orientation.height;\n        if (topZ <= TRUCK_DIMENSIONS.height - 100) { // Минимум 100мм сверху\n          possibleZ.push(topZ);\n        }\n      });\n      \n      const uniqueZ = possibleZ.filter((value, index, self) => self.indexOf(value) === index);\n      const sortedZ = uniqueZ.sort((a, b) => a - b);\n\n      // Перебираем все ориентации и позиции\n      for (const orientation of orientations) {\n        for (const z of sortedZ) {\n          if (z + orientation.height > TRUCK_DIMENSIONS.height) continue;\n\n          // Более частая сетка для точного размещения\n          const step = 25; // 25мм шаг\n          \n          for (let y = 0; y <= TRUCK_DIMENSIONS.width - 50; y += step) {\n            for (let x = 0; x <= TRUCK_DIMENSIONS.length - 50; x += step) {\n              \n              if (isPositionValid(x, y, z, orientation, placements, cargo)) {\n                const testPlacement: CargoPlacement = {\n                  cargo,\n                  x, y, z,\n                  orientation,\n                  color,\n                  projectedVertices: []\n                };\n\n                // Оценка: приоритет площади пола, потом высота, потом объем\n                const floorArea = calculateFloorArea(placements, testPlacement);\n                const heightPenalty = z * 0.001;\n                const volumePenalty = (floorArea * orientation.height) * 0.000001;\n                const score = floorArea + heightPenalty + volumePenalty;\n\n                if (score < bestScore) {\n                  bestScore = score;\n                  bestPlacement = testPlacement;\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (bestPlacement) {\n        // Вычисляем проекционные вершины для 3D отображения\n        bestPlacement.projectedVertices = calculateProjectedVertices(bestPlacement);\n        placements.push(bestPlacement);\n      }\n    });\n\n    return placements;\n  };\n\n  // Вычисление проекционных вершин для 3D отображения\n  const calculateProjectedVertices = (placement: CargoPlacement) => {\n    const { x, y, z, orientation } = placement;\n    const angle = orientation.rotationAngle * Math.PI / 180;\n    \n    // Основные вершины параллелепипеда\n    const vertices3D = [\n      [x, y, z],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z],\n      // Верхние вершины\n      [x, y, z + orientation.height],\n      [x + orientation.length * Math.cos(angle), y + orientation.length * Math.sin(angle), z + orientation.height],\n      [x + orientation.length * Math.cos(angle) - orientation.width * Math.sin(angle), \n       y + orientation.length * Math.sin(angle) + orientation.width * Math.cos(angle), z + orientation.height],\n      [x - orientation.width * Math.sin(angle), y + orientation.width * Math.cos(angle), z + orientation.height]\n    ];\n\n    // Изометрическая проекция (вид сзади 3/4)\n    return vertices3D.map(([x3d, y3d, z3d]) => {\n      const scale = 0.08; // Масштаб для отображения\n      const offsetX = 50;\n      const offsetY = 300;\n      \n      // Изометрия: поворот на 45° по Y, потом наклон на 30°\n      const projX = (x3d - y3d) * Math.cos(Math.PI / 6) * scale + offsetX;\n      const projY = offsetY - ((x3d + y3d) * Math.sin(Math.PI / 6) + z3d) * scale;\n      \n      return { x: projX, y: projY };\n    });\n  };\n\n  const placements = calculateCargoPlacement();\n\n  // Расчет статистики\n  const calculateStats = () => {\n    if (!placements.length) return null;\n\n    const floorArea = calculateFloorArea(placements);\n    \n    let maxX = 0, maxY = 0, maxZ = 0;\n    placements.forEach(p => {\n      const rad = (p.orientation.rotationAngle * Math.PI) / 180;\n      const cos = Math.abs(Math.cos(rad));\n      const sin = Math.abs(Math.sin(rad));\n      \n      const effectiveLength = p.orientation.length * cos + p.orientation.width * sin;\n      const effectiveWidth = p.orientation.length * sin + p.orientation.width * cos;\n      \n      maxX = Math.max(maxX, p.x + effectiveLength);\n      maxY = Math.max(maxY, p.y + effectiveWidth);\n      maxZ = Math.max(maxZ, p.z + p.orientation.height);\n    });\n\n    const occupiedVolume = (maxX * maxY * maxZ) / 1000000000; // в м³\n    const floorUtilization = (floorArea / ((TRUCK_DIMENSIONS.length * TRUCK_DIMENSIONS.width))) * 100;\n\n    return {\n      occupiedFloorArea: (floorArea / 1000000).toFixed(2), // в м²\n      occupiedVolume: occupiedVolume.toFixed(3),\n      floorUtilization: floorUtilization.toFixed(1),\n      dimensions: {\n        length: (maxX / 1000).toFixed(2),\n        width: (maxY / 1000).toFixed(2),\n        height: (maxZ / 1000).toFixed(2)\n      }\n    };\n  };\n\n  const stats = calculateStats();\n\n  if (!isVisible) return null;\n\n  return (\n    <Card className=\"bg-gray-800 border-gray-700\">\n      <CardHeader className=\"pb-3\">\n        <CardTitle className=\"text-white flex items-center gap-2 text-lg\">\n          <Truck className=\"h-4 w-4\" />\n          3D Визуализация размещения в кузове (вид сзади 3/4)\n        </CardTitle>\n      </CardHeader>\n      <CardContent>\n        {/* 3D SVG визуализация кузова */}\n        <div className=\"bg-gray-900 p-4 rounded-lg mb-4\">\n          <svg \n            viewBox=\"0 0 600 400\" \n            className=\"w-full h-96 border border-gray-600 bg-gray-950\"\n            style={{ maxHeight: '480px' }}\n          >\n            {/* Контур кузова в изометрии */}\n            <g stroke=\"#4B5563\" strokeWidth=\"2\" fill=\"none\">\n              {/* Задняя стенка */}\n              <rect x=\"50\" y=\"100\" width=\"163\" height=\"163\" strokeDasharray=\"3,3\" />\n              \n              {/* Правая боковая стенка */}\n              <polygon points=\"213,100 350,50 350,213 213,263\" strokeDasharray=\"3,3\" />\n              \n              {/* Пол */}\n              <polygon points=\"50,263 213,263 350,213 187,213\" fill=\"#374151\" fillOpacity=\"0.3\" />\n              \n              {/* Верх */}\n              <polygon points=\"50,100 213,100 350,50 187,50\" strokeDasharray=\"3,3\" />\n              \n              {/* Левая стенка (видимая часть) */}\n              <line x1=\"50\" y1=\"100\" x2=\"187\" y2=\"50\" strokeDasharray=\"3,3\" />\n              <line x1=\"50\" y1=\"263\" x2=\"187\" y2=\"213\" strokeDasharray=\"3,3\" />\n            </g>\n            \n            {/* Размеры кузова */}\n            <text x=\"300\" y=\"40\" textAnchor=\"middle\" fill=\"#9CA3AF\" fontSize=\"10\">\n              4200×2025×2025 мм\n            </text>\n            \n            {/* Отображение размещенных грузов */}\n            {placements.map((placement, index) => {\n              const vertices = placement.projectedVertices;\n              if (vertices.length < 8) return null;\n\n              return (\n                <g key={`cargo-3d-${index}`}>\n                  {/* Нижняя грань */}\n                  <polygon\n                    points={`${vertices[0].x},${vertices[0].y} ${vertices[1].x},${vertices[1].y} ${vertices[2].x},${vertices[2].y} ${vertices[3].x},${vertices[3].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.6\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n                  \n                  {/* Верхняя грань */}\n                  <polygon\n                    points={`${vertices[4].x},${vertices[4].y} ${vertices[5].x},${vertices[5].y} ${vertices[6].x},${vertices[6].y} ${vertices[7].x},${vertices[7].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.8\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n                  \n                  {/* Боковые грани */}\n                  <polygon\n                    points={`${vertices[1].x},${vertices[1].y} ${vertices[2].x},${vertices[2].y} ${vertices[6].x},${vertices[6].y} ${vertices[5].x},${vertices[5].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.7\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n                  \n                  <polygon\n                    points={`${vertices[2].x},${vertices[2].y} ${vertices[3].x},${vertices[3].y} ${vertices[7].x},${vertices[7].y} ${vertices[6].x},${vertices[6].y}`}\n                    fill={placement.color}\n                    fillOpacity=\"0.5\"\n                    stroke={placement.color}\n                    strokeWidth=\"1\"\n                  />\n\n                  {/* Номер груза */}\n                  <text\n                    x={(vertices[4].x + vertices[6].x) / 2}\n                    y={(vertices[4].y + vertices[6].y) / 2}\n                    textAnchor=\"middle\"\n                    dominantBaseline=\"middle\"\n                    fill=\"white\"\n                    fontSize=\"8\"\n                    fontWeight=\"bold\"\n                  >\n                    {index + 1}\n                  </text>\n                </g>\n              );\n            })}\n          </svg>\n        </div>\n\n        {/* Статистика размещения */}\n        {stats && (\n          <div className=\"grid grid-cols-2 gap-4 text-sm\">\n            <div className=\"space-y-2\">\n              <h4 className=\"font-medium text-white\">Занятые размеры:</h4>\n              <div className=\"text-gray-300 space-y-1\">\n                <div>Длина: {stats.dimensions.length} м</div>\n                <div>Ширина: {stats.dimensions.width} м</div>\n                <div>Высота: {stats.dimensions.height} м</div>\n              </div>\n            </div>\n            <div className=\"space-y-2\">\n              <h4 className=\"font-medium text-white\">Использование:</h4>\n              <div className=\"text-gray-300 space-y-1\">\n                <div>Площадь пола: {stats.occupiedFloorArea} м²</div>\n                <div>Объем: {stats.occupiedVolume} м³</div>\n                <div>Загрузка пола: {stats.floorUtilization}%</div>\n              </div>\n            </div>\n          </div>\n        )}\n\n        {/* Легенда грузов */}\n        {placements.length > 0 && (\n          <div className=\"mt-4\">\n            <h4 className=\"font-medium text-white mb-2\">Размещенные грузы:</h4>\n            <div className=\"grid grid-cols-1 gap-2 text-xs max-h-32 overflow-y-auto\">\n              {placements.map((placement, index) => (\n                <div key={`legend-${index}`} className=\"flex items-center gap-2\">\n                  <div \n                    className=\"w-3 h-3 rounded\"\n                    style={{ backgroundColor: placement.color }}\n                  />\n                  <span className=\"text-gray-300\">\n                    Груз {index + 1}: {Math.round(placement.orientation.length)}×{Math.round(placement.orientation.width)}×{Math.round(placement.orientation.height)} мм\n                    {placement.orientation.rotationAngle !== 0 && (\n                      <span className=\"text-blue-300\"> (повернут {placement.orientation.rotationAngle}°)</span>\n                    )}\n                  </span>\n                </div>\n              ))}\n            </div>\n          </div>\n        )}\n      </CardContent>\n    </Card>\n  );\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/components/TruckVisualization.tsx",
      "exists": true
    },
    "title": "components/TruckVisualization.tsx",
    "time": {
      "start": 1759134301800,
      "end": 1759134301802
    }
  }
}